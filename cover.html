
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">go-drop-logistik/app/config/config.go (0.0%)</option>
				
				<option value="file1">go-drop-logistik/app/main.go (0.0%)</option>
				
				<option value="file2">go-drop-logistik/app/middleware/auth.go (33.3%)</option>
				
				<option value="file3">go-drop-logistik/app/middleware/role.go (0.0%)</option>
				
				<option value="file4">go-drop-logistik/app/routes/routes.go (0.0%)</option>
				
				<option value="file5">go-drop-logistik/business/admins/usecase.go (0.0%)</option>
				
				<option value="file6">go-drop-logistik/business/agents/mocks/Repository.go (80.9%)</option>
				
				<option value="file7">go-drop-logistik/business/agents/mocks/Usecase.go (0.0%)</option>
				
				<option value="file8">go-drop-logistik/business/agents/usecase.go (100.0%)</option>
				
				<option value="file9">go-drop-logistik/business/drivers/usecase.go (0.0%)</option>
				
				<option value="file10">go-drop-logistik/business/manifest/usecase.go (0.0%)</option>
				
				<option value="file11">go-drop-logistik/business/manifestreceipt/usecase.go (0.0%)</option>
				
				<option value="file12">go-drop-logistik/business/phoneagent/usecase.go (0.0%)</option>
				
				<option value="file13">go-drop-logistik/business/phones/usecase.go (0.0%)</option>
				
				<option value="file14">go-drop-logistik/business/receipts/usecase.go (0.0%)</option>
				
				<option value="file15">go-drop-logistik/business/trackmanifest/usecase.go (0.0%)</option>
				
				<option value="file16">go-drop-logistik/business/tracks/usecase.go (0.0%)</option>
				
				<option value="file17">go-drop-logistik/business/trucks/usecase.go (0.0%)</option>
				
				<option value="file18">go-drop-logistik/business/users/usecase.go (0.0%)</option>
				
				<option value="file19">go-drop-logistik/cli/seeder/seeder.go (0.0%)</option>
				
				<option value="file20">go-drop-logistik/controllers/admins/http.go (0.0%)</option>
				
				<option value="file21">go-drop-logistik/controllers/admins/request/input.go (0.0%)</option>
				
				<option value="file22">go-drop-logistik/controllers/admins/response/response.go (0.0%)</option>
				
				<option value="file23">go-drop-logistik/controllers/agents/http.go (0.0%)</option>
				
				<option value="file24">go-drop-logistik/controllers/agents/request/input.go (0.0%)</option>
				
				<option value="file25">go-drop-logistik/controllers/agents/response/response.go (0.0%)</option>
				
				<option value="file26">go-drop-logistik/controllers/drivers/http.go (0.0%)</option>
				
				<option value="file27">go-drop-logistik/controllers/drivers/request/input.go (0.0%)</option>
				
				<option value="file28">go-drop-logistik/controllers/drivers/response/response.go (0.0%)</option>
				
				<option value="file29">go-drop-logistik/controllers/manifest/http.go (0.0%)</option>
				
				<option value="file30">go-drop-logistik/controllers/manifest/request/input.go (0.0%)</option>
				
				<option value="file31">go-drop-logistik/controllers/manifest/response/response.go (0.0%)</option>
				
				<option value="file32">go-drop-logistik/controllers/phones/http.go (0.0%)</option>
				
				<option value="file33">go-drop-logistik/controllers/phones/request/input.go (0.0%)</option>
				
				<option value="file34">go-drop-logistik/controllers/phones/response/response.go (0.0%)</option>
				
				<option value="file35">go-drop-logistik/controllers/receipts/http.go (0.0%)</option>
				
				<option value="file36">go-drop-logistik/controllers/receipts/request/input.go (0.0%)</option>
				
				<option value="file37">go-drop-logistik/controllers/receipts/response/response.go (0.0%)</option>
				
				<option value="file38">go-drop-logistik/controllers/tracks/http.go (0.0%)</option>
				
				<option value="file39">go-drop-logistik/controllers/tracks/request/input.go (0.0%)</option>
				
				<option value="file40">go-drop-logistik/controllers/tracks/response/response.go (0.0%)</option>
				
				<option value="file41">go-drop-logistik/controllers/trucks/http.go (0.0%)</option>
				
				<option value="file42">go-drop-logistik/controllers/trucks/request/input.go (0.0%)</option>
				
				<option value="file43">go-drop-logistik/controllers/trucks/response/response.go (0.0%)</option>
				
				<option value="file44">go-drop-logistik/controllers/users/http.go (0.0%)</option>
				
				<option value="file45">go-drop-logistik/controllers/users/request/input.go (0.0%)</option>
				
				<option value="file46">go-drop-logistik/controllers/users/response/response.go (0.0%)</option>
				
				<option value="file47">go-drop-logistik/drivers/databases/admins/mysql.go (0.0%)</option>
				
				<option value="file48">go-drop-logistik/drivers/databases/admins/record.go (0.0%)</option>
				
				<option value="file49">go-drop-logistik/drivers/databases/agents/mysql.go (0.0%)</option>
				
				<option value="file50">go-drop-logistik/drivers/databases/agents/record.go (0.0%)</option>
				
				<option value="file51">go-drop-logistik/drivers/databases/drivers/mysql.go (0.0%)</option>
				
				<option value="file52">go-drop-logistik/drivers/databases/drivers/record.go (0.0%)</option>
				
				<option value="file53">go-drop-logistik/drivers/databases/manifest/mysql.go (0.0%)</option>
				
				<option value="file54">go-drop-logistik/drivers/databases/manifest/record.go (0.0%)</option>
				
				<option value="file55">go-drop-logistik/drivers/databases/manifestreceipt/mysql.go (0.0%)</option>
				
				<option value="file56">go-drop-logistik/drivers/databases/manifestreceipt/record.go (0.0%)</option>
				
				<option value="file57">go-drop-logistik/drivers/databases/phoneagent/mysql.go (0.0%)</option>
				
				<option value="file58">go-drop-logistik/drivers/databases/phoneagent/record.go (0.0%)</option>
				
				<option value="file59">go-drop-logistik/drivers/databases/phones/mysql.go (0.0%)</option>
				
				<option value="file60">go-drop-logistik/drivers/databases/phones/record.go (0.0%)</option>
				
				<option value="file61">go-drop-logistik/drivers/databases/receipts/mysql.go (0.0%)</option>
				
				<option value="file62">go-drop-logistik/drivers/databases/receipts/record.go (0.0%)</option>
				
				<option value="file63">go-drop-logistik/drivers/databases/trackmanifest/mysql.go (0.0%)</option>
				
				<option value="file64">go-drop-logistik/drivers/databases/trackmanifest/record.go (0.0%)</option>
				
				<option value="file65">go-drop-logistik/drivers/databases/tracks/mysql.go (0.0%)</option>
				
				<option value="file66">go-drop-logistik/drivers/databases/tracks/record.go (0.0%)</option>
				
				<option value="file67">go-drop-logistik/drivers/databases/trucks/mysql.go (0.0%)</option>
				
				<option value="file68">go-drop-logistik/drivers/databases/trucks/record.go (0.0%)</option>
				
				<option value="file69">go-drop-logistik/drivers/databases/users/mysql.go (0.0%)</option>
				
				<option value="file70">go-drop-logistik/drivers/databases/users/record.go (0.0%)</option>
				
				<option value="file71">go-drop-logistik/drivers/mysql/driver.go (0.0%)</option>
				
				<option value="file72">go-drop-logistik/helper/code/receipt.go (0.0%)</option>
				
				<option value="file73">go-drop-logistik/helper/convertpointer/convertpointer.go (0.0%)</option>
				
				<option value="file74">go-drop-logistik/helper/encrypt/bcrypt.go (100.0%)</option>
				
				<option value="file75">go-drop-logistik/helper/guid/guid.go (0.0%)</option>
				
				<option value="file76">go-drop-logistik/helper/logging/log.go (33.3%)</option>
				
				<option value="file77">go-drop-logistik/helper/response/response.go (0.0%)</option>
				
				<option value="file78">go-drop-logistik/helper/statuskey/statuskey.go (0.0%)</option>
				
				<option value="file79">go-drop-logistik/helper/validation/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"

        "github.com/spf13/viper"
)

type Config struct {
        
        //! APP
        App struct {
                Env string `mapstructure:"env"`
                Debug bool `mapstructure:"debug"`
                Version string `mapstructure:"version"`
        } `mapstructure:"app"`

        //! Server
        Server struct {
                Address string `mapstructure:"address"`
                Timeout int    `mapstructure:"timeout"`
        } `mapstructure:"server"`

        //! MYSQL
        Mysql struct {
                Host string `mapstructure:"host"`
                Port string `mapstructure:"port"`
                User string `mapstructure:"user"`
                Pass string `mapstructure:"pass"`
                Name string `mapstructure:"name"`
        } `mapstructure:"mysql"`

        //! MONGO DB
        Mongo struct {
                Host string `mapstructure:"host"`
                Port string `mapstructure:"port"`
                User string `mapstructure:"user"`
                Pass string `mapstructure:"pass"`
                Name string `mapstructure:"name"`
        } `mapstructure:"mongo"`

        //! JWT
        JWT struct {
                Secret  string `mapstructure:"secret"`
                Expired int    `mapstructure:"expired"`
        } `mapstructure:"jwt"`
}

func GetConfig() Config <span class="cov0" title="0">{
        var conf Config

        viper.SetConfigName("config.prod")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(os.Getenv("APP_PATH") + "app/config/")

        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("error: ", err)
                conf.Mysql.Host = os.Getenv("MYSQL_DB_HOST")
                conf.Mysql.Port = os.Getenv("MYSQL_DB_PORT")
                conf.Mysql.User = os.Getenv("MYSQL_DB_USER")
                conf.Mysql.Pass = os.Getenv("MYSQL_DB_PASS")
                conf.Mysql.Name = os.Getenv("MYSQL_DB_NAME")

                conf.JWT.Secret = os.Getenv("JWT_SECRET")
                conf.JWT.Expired, _ = strconv.Atoi(os.Getenv("JWT_EXPIRED"))
        }</span>

        <span class="cov0" title="0">if err := viper.Unmarshal(&amp;conf); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return conf</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"

        _config "go-drop-logistik/app/config"
        _dbMysqlDriver "go-drop-logistik/drivers/mysql"
        "go-drop-logistik/helper/logging"
        "go-drop-logistik/helper/validation"

        _middleware "go-drop-logistik/app/middleware"
        _routes "go-drop-logistik/app/routes"

        _userUsecase "go-drop-logistik/business/users"
        _userController "go-drop-logistik/controllers/users"
        _userRepo "go-drop-logistik/drivers/databases/users"

        _agentUsecase "go-drop-logistik/business/agents"
        _agentController "go-drop-logistik/controllers/agents"
        _agentRepo "go-drop-logistik/drivers/databases/agents"

        _phoneAgentUsecase "go-drop-logistik/business/phoneagent"
        _phoneAgentRepo "go-drop-logistik/drivers/databases/phoneagent"

        _manifestReceiptUsecase "go-drop-logistik/business/manifestreceipt"
        _manifestReceiptRepo "go-drop-logistik/drivers/databases/manifestreceipt"

        _trackManifestUsecase "go-drop-logistik/business/trackmanifest"
        _trackManifestRepo "go-drop-logistik/drivers/databases/trackmanifest"

        _phoneUsecase "go-drop-logistik/business/phones"
        _phoneController "go-drop-logistik/controllers/phones"
        _phoneRepo "go-drop-logistik/drivers/databases/phones"

        _adminUsecase "go-drop-logistik/business/admins"
        _adminController "go-drop-logistik/controllers/admins"
        _adminRepo "go-drop-logistik/drivers/databases/admins"

        _receiptUsecase "go-drop-logistik/business/receipts"
        _receiptController "go-drop-logistik/controllers/receipts"
        _receiptRepo "go-drop-logistik/drivers/databases/receipts"

        _trackUsecase "go-drop-logistik/business/tracks"
        _trackController "go-drop-logistik/controllers/tracks"
        _trackRepo "go-drop-logistik/drivers/databases/tracks"

        _manifestUsecase "go-drop-logistik/business/manifest"
        _manifestController "go-drop-logistik/controllers/manifest"
        _manifestRepo "go-drop-logistik/drivers/databases/manifest"

        _truckUsecase "go-drop-logistik/business/trucks"
        _truckController "go-drop-logistik/controllers/trucks"
        _truckRepo "go-drop-logistik/drivers/databases/trucks"

        _driverUsecase "go-drop-logistik/business/drivers"
        _driverController "go-drop-logistik/controllers/drivers"
        _driverRepo "go-drop-logistik/drivers/databases/drivers"

        "log"
        "time"

        "go-drop-logistik/cli/seeder"

        echo "github.com/labstack/echo/v4"
)

func main() <span class="cov0" title="0">{
        configApp := _config.GetConfig()
        mysqlConfigDB := _dbMysqlDriver.ConfigDB{
                DB_Username: configApp.Mysql.User,
                DB_Password: configApp.Mysql.Pass,
                DB_Host:     configApp.Mysql.Host,
                DB_Port:     configApp.Mysql.Port,
                DB_Database: configApp.Mysql.Name,
                Env:         configApp.App.Env,
        }
        fmt.Println("User :", configApp.Mysql.User)
        fmt.Println("Host :", configApp.Mysql.Host)
        fmt.Println("Port :", configApp.Mysql.Port)
        fmt.Println("Name :", configApp.Mysql.Name)

        // mongoConfigDB := _dbMongoDriver.ConfigDB{
        //         DB_Username: configApp.MONGO_DB_USER,
        //         DB_Host:     configApp.MONGO_DB_HOST,
        //         DB_Port:     configApp.MONGO_DB_PORT,
        //         DB_Database: configApp.MONGO_DB_NAME,
        // }

        mysql_db := mysqlConfigDB.InitialMysqlDB()

        // Init Seeding
        err := seeder.Seeder(mysql_db)

        // Init Validation
        validation.Init()

        log.Println(err)

        configJWT := _middleware.ConfigJWT{
                SecretJWT:       configApp.JWT.Secret,
                ExpiresDuration: configApp.JWT.Expired,
        }

        timeoutContext := time.Duration(configApp.JWT.Expired) * time.Second

        e := echo.New()

        logger := logging.NewLogger()

        middlewareLog := _middleware.NewMiddleware(logger)

        //! REPO
        userRepo := _userRepo.NewMySQLUserRepository(mysql_db)
        phoneAgentRepo := _phoneAgentRepo.NewMySQLPhoneAgentRepository(mysql_db)
        phoneRepo := _phoneRepo.NewMySQLPhoneRepository(mysql_db)
        agentRepo := _agentRepo.NewMySQLAgentRepository(mysql_db)
        adminRepo := _adminRepo.NewMySQLAdminRepository(mysql_db)
        receiptRepo := _receiptRepo.NewMySQLReceiptRepository(mysql_db)
        manifestReceiptRepo := _manifestReceiptRepo.NewMySQLManifestReceiptRepository(mysql_db)
        manifestRepo := _manifestRepo.NewMySQLManifestRepository(mysql_db)
        truckRepo := _truckRepo.NewMySQLTruckRepository(mysql_db)
        driverRepo := _driverRepo.NewMySQLDriverRepository(mysql_db)
        trackRepo := _trackRepo.NewMySQLTrackRepository(mysql_db)
        trackManifestRepo := _trackManifestRepo.NewMySQLTrackManifestRepository(mysql_db)

        //! USECASE
        userUsecase := _userUsecase.NewUserUsecase(userRepo, &amp;configJWT, timeoutContext, logger)
        phoneUsecase := _phoneUsecase.NewPhoneUsecase(phoneRepo, &amp;configJWT, timeoutContext)
        agentUsecase := _agentUsecase.NewAgentUsecase(agentRepo, &amp;configJWT, timeoutContext, logger)
        adminUsecase := _adminUsecase.NewAdminUsecase(adminRepo, &amp;configJWT, timeoutContext, logger)
        receiptUsecase := _receiptUsecase.NewReceiptUsecase(receiptRepo, &amp;configJWT, timeoutContext, logger)
        manifestReceiptUsecase := _manifestReceiptUsecase.NewManifestReceiptUsecase(manifestReceiptRepo, receiptRepo, &amp;configJWT, timeoutContext)
        manifestUsecase := _manifestUsecase.NewManifestUsecase(manifestRepo, &amp;configJWT, timeoutContext)
        truckUsecase := _truckUsecase.NewTrucksUsecase(truckRepo, &amp;configJWT, timeoutContext)
        driverUsecase := _driverUsecase.NewDriverUsecase(driverRepo, &amp;configJWT, timeoutContext)
        phoneAgentUsecase := _phoneAgentUsecase.NewPhoneAgentUsecase(phoneAgentRepo, &amp;configJWT, timeoutContext)
        trackUsecase := _trackUsecase.NewTrackUsecase(trackRepo, &amp;configJWT, timeoutContext)
        trackManifestUsecase := _trackManifestUsecase.NewTrackManifestUsecase(trackManifestRepo, &amp;configJWT, timeoutContext)

        //! CONTROLLER
        userCtrl := _userController.NewUserController(userUsecase)
        phoneCtrl := _phoneController.NewPhonesController(phoneUsecase, phoneAgentUsecase)
        agentCtrl := _agentController.NewAgentController(agentUsecase, phoneAgentUsecase, phoneUsecase)
        adminCtrl := _adminController.NewAdminController(adminUsecase, agentUsecase)
        receiptCtrl := _receiptController.NewReceiptController(receiptUsecase, manifestReceiptUsecase, trackManifestUsecase)
        manifestCtrl := _manifestController.NewManifestController(manifestUsecase, manifestReceiptUsecase, trackManifestUsecase)
        truckCtrl := _truckController.NewTrucksController(truckUsecase)
        driverCtrl := _driverController.NewDriversController(driverUsecase)
        trackCtrl := _trackController.NewTracksController(trackUsecase, trackManifestUsecase)

        routesInit := _routes.ControllerList{
                MiddlewareLog:      middlewareLog,
                JWTMiddleware:      configJWT.Init(),
                UserController:     *userCtrl,
                AgentController:    *agentCtrl,
                AdminController:    *adminCtrl,
                ReceiptController:  *receiptCtrl,
                PhoneController:    *phoneCtrl,
                ManifestController: *manifestCtrl,
                TruckController:    *truckCtrl,
                DriverController:   *driverCtrl,
                TrackController:    *trackCtrl,
                ConfigApp:          configApp,
        }
        routesInit.RouteRegister(e)

        loc, _ := time.LoadLocation("Asia/Jakarta")
        now := time.Now().In(loc)
        fmt.Println("Location :", loc, " Time :", now.Format(time.RFC3339))

        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8000"
        }</span>

        <span class="cov0" title="0">log.Println("App :", configApp.App.Env)
        log.Println("Debug :", configApp.App.Debug)
        log.Println("App Version :", configApp.App.Version)

        logger.LogServer("Server is running").Info("Server started at port ", port)
        log.Println("listening on PORT : ", port)
        log.Fatal(e.Start(":" + port))</span>

}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middleware

import (
        "go-drop-logistik/helper/logging"
        "time"

        "github.com/golang-jwt/jwt"
        echo "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
)

type JwtCustomClaims struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Role string `json:"role"`
        jwt.StandardClaims
}

type ConfigJWT struct {
        SecretJWT       string
        ExpiresDuration int
}

type ConfigMiddleware struct {
        logger logging.Logger
}

func NewMiddleware(logger logging.Logger) ConfigMiddleware <span class="cov0" title="0">{
        return ConfigMiddleware{
                logger: logger,
        }
}</span>

func (jwtConf *ConfigJWT) Init() middleware.JWTConfig <span class="cov0" title="0">{
        return middleware.JWTConfig{
                Claims:     &amp;JwtCustomClaims{},
                SigningKey: []byte(jwtConf.SecretJWT),
        }
}</span>

// GenerateToken jwt ...
func (jwtConf *ConfigJWT) GenerateToken(userID int, name, role string) string <span class="cov8" title="1">{
        claims := JwtCustomClaims{
                userID,
                name,
                role,
                jwt.StandardClaims{
                        ExpiresAt: time.Now().Local().Add(time.Hour * time.Duration(int64(jwtConf.ExpiresDuration))).Unix(),
                },
        }

        // Create token with claims
        t := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        token, _ := t.SignedString([]byte(jwtConf.SecretJWT))

        return token
}</span>

// GetUser from jwt ...
func GetUser(c echo.Context) *JwtCustomClaims <span class="cov0" title="0">{
        user := c.Get("user").(*jwt.Token)
        claims := user.Claims.(*JwtCustomClaims)
        return claims
}</span>

func (logs *ConfigMiddleware) MiddlewareLogging(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                logs.logger.Logging(c).Info("incoming request")
                return next(c)
        }</span>
}

// func MiddlewareLoggingEntry(c echo.Context, request, response interface{}) {
//         logging.LogEntry(c, request, response).Info("incoming request")
// }
</pre>
		
		<pre class="file" id="file3" style="display: none">package middleware

import (
        "errors"
        base_response "go-drop-logistik/helper/response"
        "net/http"

        echo "github.com/labstack/echo/v4"
)

func RoleValidation(roles ...string) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(hf echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        claims := GetUser(c)

                        for _, role := range roles </span><span class="cov0" title="0">{
                                if claims.Role == role </span><span class="cov0" title="0">{
                                        return hf(c)
                                }</span>
                        }
                        <span class="cov0" title="0">return base_response.NewErrorResponse(c, http.StatusForbidden, errors.New("forbidden roles"))</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package routes

import (
        _middleware "go-drop-logistik/app/middleware"
        "go-drop-logistik/controllers/admins"
        "go-drop-logistik/controllers/agents"
        "go-drop-logistik/controllers/drivers"
        "go-drop-logistik/controllers/manifest"
        "go-drop-logistik/controllers/phones"
        "go-drop-logistik/controllers/receipts"
        "go-drop-logistik/controllers/tracks"
        "go-drop-logistik/controllers/trucks"
        "go-drop-logistik/controllers/users"

        _config "go-drop-logistik/app/config"

        echo "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        echoSwagger "github.com/swaggo/echo-swagger"
)

type ControllerList struct {
        MiddlewareLog      _middleware.ConfigMiddleware
        JWTMiddleware      middleware.JWTConfig
        UserController     users.UserController
        AgentController    agents.AgentController
        AdminController    admins.AdminController
        ReceiptController  receipts.ReceiptController
        PhoneController    phones.PhonesController
        ManifestController manifest.ManifestController
        TruckController    trucks.TrucksController
        DriverController   drivers.DriversController
        TrackController    tracks.TracksController
        ConfigApp          _config.Config
}

func (cl *ControllerList) RouteRegister(e *echo.Echo) <span class="cov0" title="0">{
        e.Use(cl.MiddlewareLog.MiddlewareLogging)

        // showing swagger files
        if cl.ConfigApp.App.Env != "PROD" </span><span class="cov0" title="0">{
                e.Static("/files", "files")
                url := echoSwagger.URL("/files/swagger.yaml")
                e.GET("/swagger/*", echoSwagger.EchoWrapHandler(url))
        }</span>
        <span class="cov0" title="0">apiV1 := e.Group("/api/v1")

        //! RESI
        apiV1.POST("/tracking", cl.ReceiptController.GetByCode)

        //! AUTH
        auth := apiV1.Group("/auth")
        auth.POST("/register", cl.UserController.Register)
        auth.POST("/login", cl.UserController.Login)

        //! AGENTS
        agent := apiV1.Group("/agent")
        agent.POST("/login", cl.AgentController.Login)
        agent.GET("/profile", cl.AgentController.GetByID, middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT", "ADMIN"))

        resi := agent.Group("/resi", middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT"))
        resi.POST("/add", cl.ReceiptController.CreateReceipt)
        resi.GET("", cl.ReceiptController.Fetch)
        resi.GET("/:id", cl.ReceiptController.GetByID)
        resi.PUT("/:id", cl.ReceiptController.Update)
        resi.DELETE("/:id/decline", cl.ReceiptController.Delete)

        manifest := agent.Group("/manifest", middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT"))
        manifest.POST("/add", cl.ManifestController.CreateManifest)
        manifest.GET("", cl.ManifestController.Fetch)
        manifest.GET("/:id", cl.ManifestController.GetByID)
        manifest.PUT("/:id", cl.ManifestController.Update)
        manifest.PUT("/:id/finish", cl.ManifestController.UpdateStatus)
        manifest.DELETE("/:id/decline", cl.ManifestController.Delete)

        manifestTrack := manifest.Group("/:id/track")
        manifestTrack.POST("/add", cl.TrackController.CreateTrack)

        agentPhone := agent.Group("/phone", middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT"))
        agentPhone.POST("/add", cl.PhoneController.StorePhone)
        agentPhone.GET("", cl.PhoneController.GetAll)
        agentPhone.DELETE("/:id", cl.PhoneController.DeletePhone)
        agentPhone.PUT("/:id", cl.PhoneController.UpdatePhone)

        drivers := agent.Group("/driver", middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT"))
        drivers.POST("/add", cl.DriverController.Store)
        drivers.GET("/:id", cl.DriverController.GetByID)
        drivers.DELETE("/:id", cl.DriverController.Delete)
        drivers.PUT("/:id", cl.DriverController.Update)

        trucks := agent.Group("/truck", middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("AGENT"))
        trucks.POST("/add", cl.TruckController.StoreTruck)
        trucks.GET("", cl.TruckController.Fetch)
        trucks.DELETE("/:id", cl.TruckController.DeleteTruck)
        trucks.PUT("/:id", cl.TruckController.UpdateTruck)

        //! ADMINS
        admin := apiV1.Group("/admin")
        admin.POST("/register", cl.AdminController.Register)
        admin.POST("/login", cl.AdminController.Login)
        admin.GET("/profile", cl.AdminController.GetByID, middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("ADMIN"))

        adminAgent := admin.Group("/agent") //, middleware.JWTWithConfig(cl.JWTMiddleware), _middleware.RoleValidation("ADMIN"))
        adminAgent.GET("", cl.AdminController.AgentFetch)
        adminAgent.GET("/:id", cl.AdminController.AgentGetByID)
        adminAgent.POST("/add", cl.AdminController.AgentRegister)
        adminAgent.PUT("/:id", cl.AdminController.AgentUpdateByID)

        //! USERS
        user := apiV1.Group("/user")
        user.GET("/", cl.UserController.GetByID, middleware.JWTWithConfig(cl.JWTMiddleware))</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package admins

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business"
        "go-drop-logistik/helper/encrypt"
        "go-drop-logistik/helper/logging"
        "strings"
        "time"
)

type AdminUsecase struct {
        adminRepository Repository
        contextTimeout  time.Duration
        jwtAuth         *middleware.ConfigJWT
        logger          logging.Logger
}

func NewAdminUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration, logger logging.Logger) Usecase <span class="cov0" title="0">{
        return &amp;AdminUsecase{
                adminRepository: ur,
                jwtAuth:         jwtauth,
                contextTimeout:  timeout,
                logger:          logger,
        }
}</span>

func (usecase *AdminUsecase) Login(ctx context.Context, email, password string, sso bool) (string, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "email": email,
                "sso":   sso,
        }

        existedUser, err := usecase.adminRepository.GetByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "susecasecess": "false",
                        "error":        err.Error(),
                }
                usecase.logger.LogEntry(request, result).Error(err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">if !encrypt.ValidateHash(password, existedUser.Password) &amp;&amp; !sso </span><span class="cov0" title="0">{
                return "", business.ErrEmailPasswordNotFound
        }</span>

        <span class="cov0" title="0">token := usecase.jwtAuth.GenerateToken(existedUser.ID, existedUser.Name, existedUser.Roles)
        result := map[string]interface{}{
                "susecasecess": "true",
        }
        usecase.logger.LogEntry(request, result).Info("incoming request")
        return token, nil</span>
}

func (usecase *AdminUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "id": id,
        }

        users, err := usecase.adminRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "error": err.Error(),
                }
                usecase.logger.LogEntry(request, result).Error(err.Error())
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "id":    users.ID,
                "name":  users.Name,
                "email": users.Email,
        }

        usecase.logger.LogEntry(request, result).Info("incoming request")

        return users, nil</span>
}

func (usecase *AdminUsecase) Register(ctx context.Context, adminDomain *Domain, sso bool) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, usecase.contextTimeout)
        defer cancel()

        request := map[string]interface{}{
                "email": adminDomain.Email,
                "name":  adminDomain.Name,
        }

        adminDomain.Roles = "ADMIN"

        existedUser, err := usecase.adminRepository.GetByEmail(ctx, adminDomain.Email)
        if err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        result := map[string]interface{}{
                                "susecasecess": "false",
                                "error":        err.Error(),
                        }
                        usecase.logger.LogEntry(request, result).Error(err.Error())
                        return err
                }</span>
        }
        <span class="cov0" title="0">if existedUser != (Domain{}) </span><span class="cov0" title="0">{
                return business.ErrDuplicateData
        }</span>

        <span class="cov0" title="0">if !sso </span><span class="cov0" title="0">{
                adminDomain.Password, _ = encrypt.Hash(adminDomain.Password)
        }</span>

        <span class="cov0" title="0">err = usecase.adminRepository.Register(ctx, adminDomain)
        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "susecasecess": "false",
                        "error":        err.Error(),
                }
                usecase.logger.LogEntry(request, result).Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "susecasecess": "true",
        }
        usecase.logger.LogEntry(request, result).Info("incoming request")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by mockery v2.10.0. DO NOT EDIT.

package mocks

import (
        context "context"
        agents "go-drop-logistik/business/agents"

        mock "github.com/stretchr/testify/mock"
)

// Repository is an autogenerated mock type for the Repository type
type Repository struct {
        mock.Mock
}

// Fetch provides a mock function with given fields: ctx, start, last
func (_m *Repository) Fetch(ctx context.Context, start int, last int) ([]agents.Domain, int, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, start, last)

        var r0 []agents.Domain
        if rf, ok := ret.Get(0).(func(context.Context, int, int) []agents.Domain); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, start, last)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]agents.Domain)
                }</span>
        }

        <span class="cov8" title="1">var r1 int
        if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, start, last)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Get(1).(int)
        }</span>

        <span class="cov8" title="1">var r2 error
        if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, start, last)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// GetByEmail provides a mock function with given fields: ctx, email
func (_m *Repository) GetByEmail(ctx context.Context, email string) (agents.ExistingDomain, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, email)

        var r0 agents.ExistingDomain
        if rf, ok := ret.Get(0).(func(context.Context, string) agents.ExistingDomain); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(agents.ExistingDomain)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *Repository) GetByID(ctx context.Context, id int) (agents.Domain, error) <span class="cov8" title="1">{
        ret := _m.Called(ctx, id)

        var r0 agents.Domain
        if rf, ok := ret.Get(0).(func(context.Context, int) agents.Domain); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(agents.Domain)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// Register provides a mock function with given fields: ctx, data
func (_m *Repository) Register(ctx context.Context, data *agents.Domain) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, data)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *agents.Domain) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// Update provides a mock function with given fields: ctx, data, id
func (_m *Repository) Update(ctx context.Context, data *agents.Domain, id int) error <span class="cov8" title="1">{
        ret := _m.Called(ctx, data, id)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *agents.Domain, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data, id)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Code generated by mockery v2.10.0. DO NOT EDIT.

package mocks

import (
        context "context"
        agents "go-drop-logistik/business/agents"

        mock "github.com/stretchr/testify/mock"
)

// Usecase is an autogenerated mock type for the Usecase type
type Usecase struct {
        mock.Mock
}

// Fetch provides a mock function with given fields: ctx, start, last
func (_m *Usecase) Fetch(ctx context.Context, start int, last int) ([]agents.Domain, int, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, start, last)

        var r0 []agents.Domain
        if rf, ok := ret.Get(0).(func(context.Context, int, int) []agents.Domain); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, start, last)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]agents.Domain)
                }</span>
        }

        <span class="cov0" title="0">var r1 int
        if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, start, last)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Get(1).(int)
        }</span>

        <span class="cov0" title="0">var r2 error
        if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok </span><span class="cov0" title="0">{
                r2 = rf(ctx, start, last)
        }</span> else<span class="cov0" title="0"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov0" title="0">return r0, r1, r2</span>
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *Usecase) GetByID(ctx context.Context, id int) (agents.Domain, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, id)

        var r0 agents.Domain
        if rf, ok := ret.Get(0).(func(context.Context, int) agents.Domain); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(agents.Domain)
        }</span>

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, id)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Login provides a mock function with given fields: ctx, email, password, sso
func (_m *Usecase) Login(ctx context.Context, email string, password string, sso bool) (string, error) <span class="cov0" title="0">{
        ret := _m.Called(ctx, email, password, sso)

        var r0 string
        if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) string); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, email, password, sso)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov0" title="0">var r1 error
        if rf, ok := ret.Get(1).(func(context.Context, string, string, bool) error); ok </span><span class="cov0" title="0">{
                r1 = rf(ctx, email, password, sso)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// Register provides a mock function with given fields: ctx, data, sso
func (_m *Usecase) Register(ctx context.Context, data *agents.Domain, sso bool) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, data, sso)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *agents.Domain, bool) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data, sso)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// Update provides a mock function with given fields: ctx, data, id
func (_m *Usecase) Update(ctx context.Context, data *agents.Domain, id int) error <span class="cov0" title="0">{
        ret := _m.Called(ctx, data, id)

        var r0 error
        if rf, ok := ret.Get(0).(func(context.Context, *agents.Domain, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(ctx, data, id)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package agents

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business"
        "go-drop-logistik/helper/encrypt"
        "go-drop-logistik/helper/logging"
        "strings"
        "time"
)

type AgentUsecase struct {
        agentRepository Repository
        contextTimeout  time.Duration
        jwtusecaseth    *middleware.ConfigJWT
        logger          logging.Logger
}

func NewAgentUsecase(ur Repository, jwtusecaseth *middleware.ConfigJWT, timeout time.Duration, logger logging.Logger) Usecase <span class="cov8" title="1">{
        return &amp;AgentUsecase{
                agentRepository: ur,
                jwtusecaseth:    jwtusecaseth,
                contextTimeout:  timeout,
                logger:          logger,
        }
}</span>

func (usecase *AgentUsecase) Login(ctx context.Context, email, password string, sso bool) (string, error) <span class="cov8" title="1">{
        existedUser, err := usecase.agentRepository.GetByEmail(ctx, email)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if !encrypt.ValidateHash(password, existedUser.Password) &amp;&amp; !sso </span><span class="cov8" title="1">{
                return "", business.ErrEmailPasswordNotFound
        }</span>

        <span class="cov8" title="1">token := usecase.jwtusecaseth.GenerateToken(existedUser.ID, existedUser.Name, existedUser.Roles)

        return token, nil</span>
}

func (usecase *AgentUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov8" title="1">{
        users, err := usecase.agentRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov8" title="1">{
                return Domain{}, err
        }</span>

        <span class="cov8" title="1">return users, nil</span>
}

func (usecase *AgentUsecase) Register(ctx context.Context, agentDomain *Domain, sso bool) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(ctx, usecase.contextTimeout)
        defer cancel()

        agentDomain.Roles = "AGENT"

        existedUser, err := usecase.agentRepository.GetByEmail(ctx, agentDomain.Email)
        if err != nil </span><span class="cov8" title="1">{
                if !strings.Contains(err.Error(), "not found") </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">if existedUser != (ExistingDomain{}) </span><span class="cov8" title="1">{
                return business.ErrDuplicateData
        }</span>

        <span class="cov8" title="1">if !sso </span><span class="cov8" title="1">{
                agentDomain.Password, _ = encrypt.Hash(agentDomain.Password)
        }</span>

        <span class="cov8" title="1">err = usecase.agentRepository.Register(ctx, agentDomain)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (usecase *AgentUsecase) Fetch(ctx context.Context, page, perpage int) ([]Domain, int, error) <span class="cov8" title="1">{
        if page &lt;= 0 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if perpage &lt;= 0 </span><span class="cov8" title="1">{
                perpage = 25
        }</span>

        <span class="cov8" title="1">res, total, err := usecase.agentRepository.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov8" title="1">{
                return []Domain{}, 0, err
        }</span>

        <span class="cov8" title="1">return res, total, nil</span>
}

func (usecase *AgentUsecase) Update(ctx context.Context, userDomain *Domain, id int) error <span class="cov8" title="1">{
        err := usecase.agentRepository.Update(ctx, userDomain, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package drivers

import (
        "context"
        "go-drop-logistik/app/middleware"
        "time"
)

type DriversUsecase struct {
        driversRepository Repository
        contextTimeout    time.Duration
        jwtAuth           *middleware.ConfigJWT
}

func NewDriverUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;DriversUsecase{
                driversRepository: ur,
                jwtAuth:           jwtauth,
                contextTimeout:    timeout,
        }
}</span>

func (usecase *DriversUsecase) Store(ctx context.Context, phoneDomain *Domain) error <span class="cov0" title="0">{
        err := usecase.driversRepository.Store(ctx, phoneDomain)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *DriversUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        phone, err := usecase.driversRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return phone, nil</span>
}

func (usecase *DriversUsecase) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        err := usecase.driversRepository.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *DriversUsecase) Update(ctx context.Context, phoneDomain *Domain, id int) error <span class="cov0" title="0">{
        err := usecase.driversRepository.Update(ctx, phoneDomain, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package manifest

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/helper/code"
        "go-drop-logistik/helper/enum"
        "time"
)

type ManifestUsecase struct {
        manifestRepository Repository
        contextTimeout     time.Duration
        jwtAuth            *middleware.ConfigJWT
}

func NewManifestUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;ManifestUsecase{
                manifestRepository: ur,
                jwtAuth:            jwtauth,
                contextTimeout:     timeout,
        }
}</span>

func (usecase *ManifestUsecase) StoreManifest(ctx context.Context, manifestDomain *Domain) error <span class="cov0" title="0">{
        manifestDomain.Code = code.GenerateManifest()
        manifestDomain.Status = enum.PROCESS

        err := usecase.manifestRepository.StoreManifest(ctx, manifestDomain)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ManifestUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        manifest, err := usecase.manifestRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return manifest, nil</span>
}

func (usecase *ManifestUsecase) Fetch(ctx context.Context, page, perpage int) ([]Domain, int, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if perpage &lt;= 0 </span><span class="cov0" title="0">{
                perpage = 25
        }</span>

        <span class="cov0" title="0">res, total, err := usecase.manifestRepository.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">return res, total, nil</span>
}

func (usecase *ManifestUsecase) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        err := usecase.manifestRepository.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ManifestUsecase) Update(ctx context.Context, manifestDomain *Domain, id int) error <span class="cov0" title="0">{
        err := usecase.manifestRepository.Update(ctx, manifestDomain, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package manifestreceipt

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/receipts"
        "go-drop-logistik/helper/enum"
        "time"
)

type ManifestReceiptUsecase struct {
        manifestReceiptRepository Repository
        receiptRepository         receipts.Repository
        contextTimeout            time.Duration
        jwtAuth                   *middleware.ConfigJWT
}

func NewManifestReceiptUsecase(ur Repository, rr receipts.Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;ManifestReceiptUsecase{
                manifestReceiptRepository: ur,
                receiptRepository:         rr,
                jwtAuth:                   jwtauth,
                contextTimeout:            timeout,
        }
}</span>

func (usecase *ManifestReceiptUsecase) Store(ctx context.Context, ManifestId, ReceiptId int) error <span class="cov0" title="0">{
        err := usecase.manifestReceiptRepository.Store(ctx, ManifestId, ReceiptId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ManifestReceiptUsecase) GetAllByManifestID(ctx context.Context, id int) ([]Domain, error) <span class="cov0" title="0">{
        res, err := usecase.manifestReceiptRepository.GetAllByManifestID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, err
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}

func (usecase *ManifestReceiptUsecase) GetByManifestID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        res, err := usecase.manifestReceiptRepository.GetByManifestID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func (usecase *ManifestReceiptUsecase) GetByReceiptID(ctx context.Context, id int) (int, error) <span class="cov0" title="0">{
        res, err := usecase.manifestReceiptRepository.GetByReceiptID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func (usecase *ManifestReceiptUsecase) DeleteByReceipt(ctx context.Context, ReceiptId int) error <span class="cov0" title="0">{
        err := usecase.manifestReceiptRepository.DeleteByReceipt(ctx, ReceiptId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ManifestReceiptUsecase) DeleteByManifest(ctx context.Context, manifestId int) error <span class="cov0" title="0">{
        err := usecase.manifestReceiptRepository.DeleteByManifest(ctx, manifestId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ManifestReceiptUsecase) UpdateStatusByManifest(ctx context.Context, manifestId int) error <span class="cov0" title="0">{
        res, err := usecase.manifestReceiptRepository.GetAllByManifestID(ctx, manifestId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, value := range res </span><span class="cov0" title="0">{
                err := usecase.receiptRepository.Update(ctx, &amp;receipts.Domain{Status: enum.SUCCESS}, value.ReceiptID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package phoneagent

import (
        "context"
        "go-drop-logistik/app/middleware"
        "time"
)

type PhoneAgentUsecase struct {
        phoneAgentRepository Repository
        contextTimeout       time.Duration
        jwtAuth              *middleware.ConfigJWT
}

func NewPhoneAgentUsecase(pa Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;PhoneAgentUsecase{
                phoneAgentRepository: pa,
                jwtAuth:              jwtauth,
                contextTimeout:       timeout,
        }
}</span>

func (usecase *PhoneAgentUsecase) Store(ctx context.Context, phoneId, agentId int) error <span class="cov0" title="0">{
        err := usecase.phoneAgentRepository.Store(ctx, phoneId, agentId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *PhoneAgentUsecase) GetAllByAgentID(ctx context.Context, Id int) ([]Domain, error) <span class="cov0" title="0">{
        result, err := usecase.phoneAgentRepository.GetAllByAgentID(ctx, Id)
        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (usecase *PhoneAgentUsecase) GetByAgentID(ctx context.Context, Id int) (Domain, error) <span class="cov0" title="0">{
        result, err := usecase.phoneAgentRepository.GetByAgentID(ctx, Id)
        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (usecase *PhoneAgentUsecase) Delete(ctx context.Context, agentId, phoneId int) error <span class="cov0" title="0">{
        err := usecase.phoneAgentRepository.Delete(ctx, agentId, phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package phones

import (
        "context"
        "go-drop-logistik/app/middleware"
        "time"
)

type PhoneUsecase struct {
        phoneRepository Repository
        contextTimeout  time.Duration
        jwtAuth         *middleware.ConfigJWT
}

func NewPhoneUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;PhoneUsecase{
                phoneRepository: ur,
                jwtAuth:         jwtauth,
                contextTimeout:  timeout,
        }
}</span>

func (usecase *PhoneUsecase) StorePhone(ctx context.Context, phoneDomain *Domain, id int) (int, error) <span class="cov0" title="0">{
        phoneId, err := usecase.phoneRepository.StorePhone(ctx, phoneDomain)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return phoneId, nil</span>
}

func (usecase *PhoneUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        phone, err := usecase.phoneRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return phone, nil</span>
}

func (usecase *PhoneUsecase) Delete(ctx context.Context, phoneId int) error <span class="cov0" title="0">{
        err := usecase.phoneRepository.Delete(ctx, phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *PhoneUsecase) Update(ctx context.Context, phoneDomain *Domain, id int) error <span class="cov0" title="0">{
        err := usecase.phoneRepository.Update(ctx, phoneDomain, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package receipts

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/helper/code"
        "go-drop-logistik/helper/enum"
        "go-drop-logistik/helper/logging"
        "time"
)

type ReceiptUsecase struct {
        receiptRepository Repository
        contextTimeout    time.Duration
        jwtAuth           *middleware.ConfigJWT
        logger            logging.Logger
}

func NewReceiptUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration, logger logging.Logger) Usecase <span class="cov0" title="0">{
        return &amp;ReceiptUsecase{
                receiptRepository: ur,
                jwtAuth:           jwtauth,
                contextTimeout:    timeout,
                logger:            logger,
        }
}</span>

func (usecase *ReceiptUsecase) StoreReceipt(ctx context.Context, receiptDomain *Domain) (int, error) <span class="cov0" title="0">{
        receiptDomain.Code = code.GenerateReceipt()
        receiptDomain.Status = enum.PROCESS

        receiptId, err := usecase.receiptRepository.StoreReceipt(ctx, receiptDomain)
        if err != nil </span><span class="cov0" title="0">{
                return receiptId, err
        }</span>

        <span class="cov0" title="0">return receiptId, nil</span>
}

func (usecase *ReceiptUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        users, err := usecase.receiptRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

func (usecase *ReceiptUsecase) GetByCode(ctx context.Context, code string) (TrackDomain, error) <span class="cov0" title="0">{
        result, err := usecase.receiptRepository.GetByCode(ctx, code)

        if err != nil </span><span class="cov0" title="0">{
                return TrackDomain{}, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

func (usecase *ReceiptUsecase) Fetch(ctx context.Context, page, perpage int) ([]Domain, int, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if perpage &lt;= 0 </span><span class="cov0" title="0">{
                perpage = 25
        }</span>

        <span class="cov0" title="0">res, total, err := usecase.receiptRepository.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">return res, total, nil</span>
}

func (usecase *ReceiptUsecase) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        err := usecase.receiptRepository.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *ReceiptUsecase) Update(ctx context.Context, manifestDomain *Domain, id int) error <span class="cov0" title="0">{
        err := usecase.receiptRepository.Update(ctx, manifestDomain, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package trackmanifest

import (
        "context"
        "go-drop-logistik/app/middleware"
        "time"
)

type TrackManifestUsecase struct {
        trackManifestRepository Repository
        contextTimeout          time.Duration
        jwtAuth                 *middleware.ConfigJWT
}

func NewTrackManifestUsecase(repo Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;TrackManifestUsecase{
                trackManifestRepository: repo,
                jwtAuth:                 jwtauth,
                contextTimeout:          timeout,
        }
}</span>

func (usecase *TrackManifestUsecase) Store(ctx context.Context, manifestId, trackId int) error <span class="cov0" title="0">{
        err := usecase.trackManifestRepository.Store(ctx, manifestId, trackId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *TrackManifestUsecase) GetByManifestID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        res, err := usecase.trackManifestRepository.GetByManifestID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func (usecase *TrackManifestUsecase) GetAllByManifestID(ctx context.Context, id int) ([]Domain, error) <span class="cov0" title="0">{
        res, err := usecase.trackManifestRepository.GetAllByManifestID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, err
        }</span>

        <span class="cov0" title="0">return res, nil</span>
}

func (usecase *TrackManifestUsecase) DeleteByManifest(ctx context.Context, manifestId int) error <span class="cov0" title="0">{
        err := usecase.trackManifestRepository.DeleteByManifest(ctx, manifestId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package tracks

import (
        "context"
        "errors"
        "fmt"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/helper/enum"
        "time"
)

type TrackUsecase struct {
        trackRepository Repository
        contextTimeout  time.Duration
        jwtAuth         *middleware.ConfigJWT
}

func NewTrackUsecase(repo Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;TrackUsecase{
                trackRepository: repo,
                jwtAuth:         jwtauth,
                contextTimeout:  timeout,
        }
}</span>

func (usecase *TrackUsecase) StoreTrack(ctx context.Context, trackDomain *Domain, agentName string) (int, error) <span class="cov0" title="0">{
        if trackDomain.Message == fmt.Sprintf("%s %s", enum.TRACKING_PROCESS_MESSAGE, agentName) </span><span class="cov0" title="0">{
                trackDomain.Message = fmt.Sprintf("%s %s", enum.TRACKING_PROCESS_MESSAGE, agentName)
        }</span> else<span class="cov0" title="0"> if trackDomain.Message == enum.TRACKING_SHIPPING_MESSAGE </span><span class="cov0" title="0">{
                trackDomain.Message = enum.TRACKING_SHIPPING_MESSAGE
        }</span> else<span class="cov0" title="0"> if trackDomain.Message == enum.TRACKING_SUCCESS_MESSAGE </span><span class="cov0" title="0">{
                trackDomain.Message = enum.TRACKING_SUCCESS_MESSAGE
        }</span> else<span class="cov0" title="0"> {
                return 0, errors.New("message not found")
        }</span>

        <span class="cov0" title="0">id, err := usecase.trackRepository.StoreTrack(ctx, trackDomain)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return id, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package trucks

import (
        "context"
        "go-drop-logistik/app/middleware"
        "time"
)

type TrucksUsecase struct {
        truckRepository Repository
        contextTimeout  time.Duration
        jwtAuth         *middleware.ConfigJWT
}

func NewTrucksUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration) Usecase <span class="cov0" title="0">{
        return &amp;TrucksUsecase{
                truckRepository: ur,
                jwtAuth:         jwtauth,
                contextTimeout:  timeout,
        }
}</span>

func (usecase *TrucksUsecase) StoreTruck(ctx context.Context, truckDomain *Domain) error <span class="cov0" title="0">{
        err := usecase.truckRepository.StoreTruck(ctx, truckDomain)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *TrucksUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        phone, err := usecase.truckRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">return phone, nil</span>
}

func (usecase *TrucksUsecase) Delete(ctx context.Context, Id int) error <span class="cov0" title="0">{

        err := usecase.truckRepository.Delete(ctx, Id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *TrucksUsecase) Update(ctx context.Context, truckDomain *Domain, id int) error <span class="cov0" title="0">{
        err := usecase.truckRepository.Update(ctx, truckDomain, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (usecase *TrucksUsecase) Fetch(ctx context.Context, page, perpage int) ([]Domain, int, error) <span class="cov0" title="0">{
        if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if perpage &lt;= 0 </span><span class="cov0" title="0">{
                perpage = 25
        }</span>

        <span class="cov0" title="0">res, total, err := usecase.truckRepository.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return []Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">return res, total, nil</span>
}

</pre>
		
		<pre class="file" id="file18" style="display: none">package users

import (
        "context"
        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business"
        "go-drop-logistik/helper/encrypt"
        "go-drop-logistik/helper/logging"
        "strings"
        "time"
)

type UserUsecase struct {
        userRepository Repository
        contextTimeout time.Duration
        jwtAuth        *middleware.ConfigJWT
        logger         logging.Logger
}

func NewUserUsecase(ur Repository, jwtauth *middleware.ConfigJWT, timeout time.Duration, logger logging.Logger) Usecase <span class="cov0" title="0">{
        return &amp;UserUsecase{
                userRepository: ur,
                jwtAuth:        jwtauth,
                contextTimeout: timeout,
                logger:         logger,
        }
}</span>

func (uc *UserUsecase) Login(ctx context.Context, email, password string, sso bool) (string, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "email": email,
                "sso":   sso,
        }

        existedUser, err := uc.userRepository.GetByEmail(ctx, email)
        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "success": "false",
                        "error":   err.Error(),
                }
                uc.logger.LogEntry(request, result).Error(err.Error())
                return "", err
        }</span>

        <span class="cov0" title="0">if !encrypt.ValidateHash(password, existedUser.Password) &amp;&amp; !sso </span><span class="cov0" title="0">{
                return "", business.ErrEmailPasswordNotFound
        }</span>

        <span class="cov0" title="0">token := uc.jwtAuth.GenerateToken(existedUser.ID, existedUser.Name, existedUser.Roles)
        result := map[string]interface{}{
                "success": "true",
        }
        uc.logger.LogEntry(request, result).Info("incoming request")
        return token, nil</span>
}

func (uc *UserUsecase) GetByID(ctx context.Context, id int) (Domain, error) <span class="cov0" title="0">{
        request := map[string]interface{}{
                "id": id,
        }

        users, err := uc.userRepository.GetByID(ctx, id)

        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "error": err.Error(),
                }
                uc.logger.LogEntry(request, result).Error(err.Error())
                return Domain{}, err
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "id":    users.ID,
                "name":  users.Name,
                "email": users.Email,
        }

        uc.logger.LogEntry(request, result).Info("incoming request")

        return users, nil</span>
}

func (uc *UserUsecase) Register(ctx context.Context, userDomain *Domain, sso bool) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, uc.contextTimeout)
        defer cancel()

        request := map[string]interface{}{
                "email": userDomain.Email,
                "name":  userDomain.Name,
        }

        existedUser, err := uc.userRepository.GetByEmail(ctx, userDomain.Email)
        if err != nil </span><span class="cov0" title="0">{
                if !strings.Contains(err.Error(), "not found") </span><span class="cov0" title="0">{
                        result := map[string]interface{}{
                                "success": "false",
                                "error":   err.Error(),
                        }
                        uc.logger.LogEntry(request, result).Error(err.Error())
                        return err
                }</span>
        }
        <span class="cov0" title="0">if existedUser != (Domain{}) </span><span class="cov0" title="0">{
                return business.ErrDuplicateData
        }</span>

        <span class="cov0" title="0">if !sso </span><span class="cov0" title="0">{
                userDomain.Password, _ = encrypt.Hash(userDomain.Password)
        }</span>

        <span class="cov0" title="0">err = uc.userRepository.Register(ctx, userDomain)
        if err != nil </span><span class="cov0" title="0">{
                result := map[string]interface{}{
                        "success": "false",
                        "error":   err.Error(),
                }
                uc.logger.LogEntry(request, result).Error(err.Error())
                return err
        }</span>

        <span class="cov0" title="0">result := map[string]interface{}{
                "success": "true",
        }
        uc.logger.LogEntry(request, result).Info("incoming request")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package seeder

import (
        "errors"
        "fmt"
        "go-drop-logistik/helper/encrypt"
        "log"
        "time"

        "gorm.io/gorm"
)

type Admins struct {
        ID        int `gorm:"primary_key"`
        Name      string
        Password  string
        Email     string
        Roles     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func Seeder(Conn *gorm.DB) error <span class="cov0" title="0">{
        log.Println("Init seeder")

        // Admins
        admin := Admins{}
        result := Conn.Where("name = ? ", "Admin").First(&amp;admin)
        if result.Error == nil </span><span class="cov0" title="0">{
                return errors.New("[error] failed to execute admin seeder query because data already exist")
        }</span>

        <span class="cov0" title="0">admin.Name = "Admin"
        admin.Password, _ = encrypt.Hash("admin")
        admin.Email = "admin@gmail.com"
        admin.Roles = "ADMIN"

        result = Conn.Create(&amp;admin)

        if result.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("[error] failed to execute admin seeder query %s", result.Error)
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("[success] success to execute seeder query")</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package admins

import (
        "net/http"
        "strconv"

        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/admins"
        "go-drop-logistik/business/agents"
        "go-drop-logistik/controllers/admins/request"
        "go-drop-logistik/controllers/admins/response"
        base_response "go-drop-logistik/helper/response"
        "go-drop-logistik/helper/validation"

        echo "github.com/labstack/echo/v4"
)

type AdminController struct {
        adminUsecase admins.Usecase
        agentUsecase agents.Usecase
}

func NewAdminController(su admins.Usecase, au agents.Usecase) *AdminController <span class="cov0" title="0">{
        return &amp;AdminController{
                adminUsecase: su,
                agentUsecase: au,
        }
}</span>

func (controller *AdminController) Register(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Admins{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.adminUsecase.Register(ctx, req.ToDomain(), false)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *AdminController) Login(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        var userLogin request.Admins
        if err := c.Bind(&amp;userLogin); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">token, err := controller.adminUsecase.Login(ctx, userLogin.Email, userLogin.Password, false)

        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">result := struct {
                Token string `json:"token"`
        }{Token: token}

        return base_response.NewSuccessResponse(c, result)</span>
}

func (controller *AdminController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := middleware.GetUser(c).ID

        user, err := controller.adminUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(user))</span>
}

func (controller *AdminController) AgentGetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        user, err := controller.agentUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.AgentFromDomain(user))</span>
}

func (controller *AdminController) AgentRegister(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Agents{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">validateMessage, validate, err := validation.Validate(&amp;req)

        if validate </span><span class="cov0" title="0">{
                return base_response.NewErrorValidateResponse(c, http.StatusBadRequest, err, validateMessage)
        }</span>

        <span class="cov0" title="0">err = controller.agentUsecase.Register(ctx, req.AgentToDomain(), false)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *AdminController) AgentFetch(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        page, _ := strconv.Atoi(c.QueryParam("page"))
        perpage, _ := strconv.Atoi(c.QueryParam("per_page"))

        agents, count, err := controller.agentUsecase.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.AgentFromListDomain(agents, count))</span>
}

func (controller *AdminController) AgentUpdateByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := c.Param("id")
        idInt, _ := strconv.Atoi(id)

        req := request.Agents{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.agentUsecase.Update(ctx, req.AgentToDomain(), idInt)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">user, err := controller.agentUsecase.GetByID(ctx, idInt)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.AgentFromDomain(user))</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package request

import (
        "go-drop-logistik/business/admins"
        "go-drop-logistik/business/agents"
)

type (
        Admins struct {
                Name     string `json:"name"`
                Password string `json:"password,omitempty"`
                Email    string `json:"email"`
        }
        Agents struct {
                Name      string  `json:"name" validate:"required"`
                Password  string  `json:"password,omitempty" validate:"required"`
                Email     string  `json:"email" validate:"required"`
                Address   string  `json:"address" validate:"required"`
                Balance   float64 `json:"balance" validate:"required"`
                Latitude  float64 `json:"latitude" validate:"required"`
                Longitude float64 `json:"longitude" validate:"required"`
        }
)

func (req *Admins) ToDomain() *admins.Domain <span class="cov0" title="0">{
        return &amp;admins.Domain{
                Name:     req.Name,
                Password: req.Password,
                Email:    req.Email,
        }
}</span>

func (req *Agents) AgentToDomain() *agents.Domain <span class="cov0" title="0">{
        return &amp;agents.Domain{
                Name:      req.Name,
                Password:  req.Password,
                Email:     req.Email,
                Address:   req.Address,
                Balance:   req.Balance,
                Latitude:  req.Latitude,
                Longitude: req.Longitude,
        }
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package response

import (
        "go-drop-logistik/business/admins"
        "go-drop-logistik/business/agents"
)

type Admins struct {
        ID    int    `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

type Agents struct {
        ID        int     `json:"id"`
        Name      string  `json:"name"`
        Email     string  `json:"email"`
        Address   string  `json:"address"`
        Balance   float64 `json:"balance"`
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
}

type AgentsPageResponse struct {
        Users *[]Agents `json:"agents"`
        Total int       `json:"total"`
}

func FromDomain(adminDomain admins.Domain) Admins <span class="cov0" title="0">{
        return Admins{
                ID:    adminDomain.ID,
                Name:  adminDomain.Name,
                Email: adminDomain.Email,
        }
}</span>

func AgentFromDomain(agentDomain agents.Domain) Agents <span class="cov0" title="0">{
        return Agents{
                ID:        agentDomain.ID,
                Name:      agentDomain.Name,
                Email:     agentDomain.Email,
                Address:   agentDomain.Address,
                Balance:   agentDomain.Balance,
                Latitude:  agentDomain.Latitude,
                Longitude: agentDomain.Longitude,
        }
}</span>

func AgentFromListDomain(agentDomain []agents.Domain, Count int) *AgentsPageResponse <span class="cov0" title="0">{
        allAgent := []Agents{}
        for _, value := range agentDomain </span><span class="cov0" title="0">{
                agent := Agents{
                        ID:        value.ID,
                        Name:      value.Name,
                        Email:     value.Email,
                        Address:   value.Address,
                        Balance:   value.Balance,
                        Latitude:  value.Latitude,
                        Longitude: value.Longitude,
                }
                allAgent = append(allAgent, agent)
        }</span>
        <span class="cov0" title="0">result := AgentsPageResponse{}
        result.Users = &amp;allAgent
        result.Total = Count
        return &amp;result</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package agents

import (
        "net/http"

        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/agents"
        "go-drop-logistik/business/phoneagent"
        "go-drop-logistik/business/phones"
        "go-drop-logistik/controllers/agents/request"
        "go-drop-logistik/controllers/agents/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type AgentController struct {
        agentUsecase      agents.Usecase
        phoneAgentUsecase phoneagent.Usecase
        phoneUsecase      phones.Usecase
}

func NewAgentController(ag agents.Usecase, pa phoneagent.Usecase, ph phones.Usecase) *AgentController <span class="cov0" title="0">{
        return &amp;AgentController{
                agentUsecase:      ag,
                phoneAgentUsecase: pa,
                phoneUsecase:      ph,
        }
}</span>

func (controller *AgentController) Login(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        var userLogin request.Agents
        if err := c.Bind(&amp;userLogin); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">token, err := controller.agentUsecase.Login(ctx, userLogin.Email, userLogin.Password, false)

        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">result := struct {
                Token string `json:"token"`
        }{Token: token}

        return base_response.NewSuccessResponse(c, result)</span>
}

func (controller *AgentController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := middleware.GetUser(c).ID

        user, err := controller.agentUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">phone, _ := controller.phoneAgentUsecase.GetAllByAgentID(ctx, id)

        for _, phones := range phone </span><span class="cov0" title="0">{
                number, _ := controller.phoneUsecase.GetByID(ctx, phones.PhoneID)
                user.Phone = append(user.Phone, number.Phone)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(&amp;user))</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package request

import (
        "go-drop-logistik/business/agents"
)

type Agents struct {
        Name     string `json:"name"`
        Password string `json:"password,omitempty"`
        Email    string `json:"email"`
}

func (req *Agents) ToDomain() *agents.Domain <span class="cov0" title="0">{
        return &amp;agents.Domain{
                Name:     req.Name,
                Password: req.Password,
                Email:    req.Email,
        }
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package response

import (
        "go-drop-logistik/business/agents"
)

type Agents struct {
        ID        int      `json:"id"`
        Name      string   `json:"name"`
        Email     string   `json:"email"`
        Phone     []string `json:"phone"`
        Address   string   `json:"address"`
        Balance   float64  `json:"balance"`
        Latitude  float64  `json:"latitude"`
        Longitude float64  `json:"longitude"`
}

type TrackAgentResponse struct {
        ID        int      `json:"id"`
        Name      string   `json:"name"`
        Address   string   `json:"address"`
        Latitude  float64  `json:"latitude"`
        Longitude float64  `json:"longitude"`
}

func FromDomain(userDomain *agents.Domain) (res *Agents) <span class="cov0" title="0">{
        if userDomain != nil </span><span class="cov0" title="0">{
                res = &amp;Agents{
                        ID:        userDomain.ID,
                        Name:      userDomain.Name,
                        Email:     userDomain.Email,
                        Phone:     userDomain.Phone,
                        Address:   userDomain.Address,
                        Balance:   userDomain.Balance,
                        Latitude:  userDomain.Latitude,
                        Longitude: userDomain.Longitude,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}

func FromTrackDomain(userDomain *agents.Domain) (res *TrackAgentResponse) <span class="cov0" title="0">{
        if userDomain != nil </span><span class="cov0" title="0">{
                res = &amp;TrackAgentResponse{
                        ID:        userDomain.ID,
                        Name:      userDomain.Name,
                        Address:   userDomain.Address,
                        Latitude:  userDomain.Latitude,
                        Longitude: userDomain.Longitude,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}</pre>
		
		<pre class="file" id="file26" style="display: none">package drivers

import (
        "net/http"
        "strconv"

        "go-drop-logistik/business/drivers"
        "go-drop-logistik/controllers/drivers/request"
        "go-drop-logistik/controllers/drivers/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type DriversController struct {
        driversUsecase drivers.Usecase
}

func NewDriversController(uc drivers.Usecase) *DriversController <span class="cov0" title="0">{
        return &amp;DriversController{
                driversUsecase: uc,
        }
}</span>

func (controller *DriversController) Store(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Drivers{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.driversUsecase.Store(ctx, req.ToDomain())
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *DriversController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        driver, err := controller.driversUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(&amp;driver))</span>
}

func (controller *DriversController) Delete(c echo.Context) error <span class="cov0" title="0">{
        id, _ := strconv.Atoi(c.Param("id"))
        ctx := c.Request().Context()

        err := controller.driversUsecase.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Delete Successfully")</span>
}

func (controller *DriversController) Update(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        id, _ := strconv.Atoi(c.Param("id"))

        req := request.Drivers{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">err := controller.driversUsecase.Update(ctx, req.ToDomain(), id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package request

import "go-drop-logistik/business/drivers"

type Drivers struct {
        Name    string `json:"name"`
        Phone   string `json:"phone"`
        Address string `json:"address"`
        TruckID int    `json:"truck_id"`
}

func (req *Drivers) ToDomain() *drivers.Domain <span class="cov0" title="0">{
        return &amp;drivers.Domain{
                Name:    req.Name,
                Phone:   req.Phone,
                Address: req.Address,
                TruckID: req.TruckID,
        }
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package response

import (
        "go-drop-logistik/business/drivers"
        truckResp "go-drop-logistik/controllers/trucks/response"
)

type Drivers struct {
        Name    string            `json:"name"`
        Phone   string            `json:"phone"`
        Address string            `json:"address"`
        Truck   *truckResp.Trucks `json:"truck"`
}

func FromDomain(driverDomain *drivers.Domain) (res *Drivers) <span class="cov0" title="0">{
        if driverDomain != nil </span><span class="cov0" title="0">{
                res = &amp;Drivers{
                        Name:    driverDomain.Name,
                        Phone:   driverDomain.Phone,
                        Address: driverDomain.Address,
                        Truck:   truckResp.FromDomain(driverDomain.Truck),
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package manifest

import (
        "net/http"
        "strconv"

        "go-drop-logistik/business/manifest"
        "go-drop-logistik/business/manifestreceipt"
        "go-drop-logistik/business/trackmanifest"
        "go-drop-logistik/controllers/manifest/request"
        "go-drop-logistik/controllers/manifest/response"
        "go-drop-logistik/helper/enum"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type ManifestController struct {
        manifestUsecase        manifest.Usecase
        manifestreceiptUsecase manifestreceipt.Usecase
        trackManifestUsecase   trackmanifest.Usecase
}

func NewManifestController(uc manifest.Usecase, mr manifestreceipt.Usecase, tr trackmanifest.Usecase) *ManifestController <span class="cov0" title="0">{
        return &amp;ManifestController{
                manifestUsecase:        uc,
                manifestreceiptUsecase: mr,
                trackManifestUsecase:   tr,
        }
}</span>

func (controller *ManifestController) CreateManifest(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Manifest{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.manifestUsecase.StoreManifest(ctx, req.ToDomain())
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *ManifestController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        manifest, err := controller.manifestUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">receipt, err := controller.manifestreceiptUsecase.GetAllByManifestID(ctx, manifest.ID)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">for _, value := range receipt </span><span class="cov0" title="0">{
                manifest.Receipt = append(manifest.Receipt, *value.Receipt)
        }</span>

        <span class="cov0" title="0">tracks, err := controller.trackManifestUsecase.GetAllByManifestID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">for _, value := range tracks </span><span class="cov0" title="0">{
                manifest.Tracks = append(manifest.Tracks, *value.Track)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(&amp;manifest))</span>
}

func (controller *ManifestController) Fetch(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        page, _ := strconv.Atoi(c.QueryParam("page"))
        perpage, _ := strconv.Atoi(c.QueryParam("per_page"))

        manifest, count, err := controller.manifestUsecase.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromListDomain(manifest, count))</span>
}

func (controller *ManifestController) Delete(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        err := controller.manifestUsecase.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.manifestreceiptUsecase.DeleteByManifest(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.trackManifestUsecase.DeleteByManifest(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Delete Successfully")</span>
}

func (controller *ManifestController) Update(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        req := request.ManifestUpdate{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.manifestUsecase.Update(ctx, req.ToDomain(), id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}

func (controller *ManifestController) UpdateStatus(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        err := controller.manifestUsecase.Update(ctx, &amp;manifest.Domain{Status: enum.SUCCESS}, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.manifestreceiptUsecase.UpdateStatusByManifest(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package request

import "go-drop-logistik/business/manifest"

type Manifest struct {
        DriverID int `json:"driver_id"`
}

func (req *Manifest) ToDomain() *manifest.Domain <span class="cov0" title="0">{
        return &amp;manifest.Domain{
                DriverID: req.DriverID,
        }
}</span>

type ManifestUpdate struct {
        Status   string `json:"status"`
        DriverID int    `json:"driver_id"`
}

func (req *ManifestUpdate) ToDomain() *manifest.Domain <span class="cov0" title="0">{
        return &amp;manifest.Domain{
                Status:   req.Status,
                DriverID: req.DriverID,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package response

import (
        "go-drop-logistik/business/manifest"
        driverResp "go-drop-logistik/controllers/drivers/response"
        receiptResp "go-drop-logistik/controllers/receipts/response"
        trackResp "go-drop-logistik/controllers/tracks/response"
)

type Manifest struct {
        ID        int                     `json:"id"`
        Code      string                  `json:"code"`
        Status    string                  `json:"status"`
        Receipt   *[]receiptResp.Receipts `json:"receipts"`
        Driver    *driverResp.Drivers     `json:"driver"`
        Tracks    *[]trackResp.Track      `json:"track"`
}

type ManifestResponse struct {
        ID        int                 `json:"id"`
        Code      string              `json:"code"`
        Status    string              `json:"status"`
        Driver    *driverResp.Drivers `json:"driver"`
}

type ManifestPageResponse struct {
        Manifest *[]ManifestResponse `json:"manifest"`
        Total    int                 `json:"total"`
}

func FromDomain(manifestDomain *manifest.Domain) (res *Manifest) <span class="cov0" title="0">{
        if manifestDomain != nil </span><span class="cov0" title="0">{
                res = &amp;Manifest{
                        ID:        manifestDomain.ID,
                        Code:      manifestDomain.Code,
                        Status:    manifestDomain.Status,
                        Receipt:   receiptResp.FromManifestListDomain(&amp;manifestDomain.Receipt),
                        Driver:    driverResp.FromDomain(manifestDomain.Driver),
                        Tracks:    trackResp.FromListDomain(&amp;manifestDomain.Tracks),
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}

func FromListDomain(manifestDomain []manifest.Domain, Count int) *ManifestPageResponse <span class="cov0" title="0">{
        allManifest := []ManifestResponse{}
        for _, value := range manifestDomain </span><span class="cov0" title="0">{
                manifest := ManifestResponse{
                        ID:        value.ID,
                        Code:      value.Code,
                        Status:    value.Status,
                        Driver:    driverResp.FromDomain(value.Driver),
                }
                allManifest = append(allManifest, manifest)
        }</span>
        <span class="cov0" title="0">result := ManifestPageResponse{}
        result.Manifest = &amp;allManifest
        result.Total = Count
        return &amp;result</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package phones

import (
        "net/http"
        "strconv"

        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/phoneagent"
        "go-drop-logistik/business/phones"
        "go-drop-logistik/controllers/phones/request"
        "go-drop-logistik/controllers/phones/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type PhonesController struct {
        phonesUsecase     phones.Usecase
        phoneAgentUsecase phoneagent.Usecase
}

func NewPhonesController(ph phones.Usecase, pa phoneagent.Usecase) *PhonesController <span class="cov0" title="0">{
        return &amp;PhonesController{
                phonesUsecase:     ph,
                phoneAgentUsecase: pa,
        }
}</span>

func (controller *PhonesController) StorePhone(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := middleware.GetUser(c).ID

        req := request.Phone{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">phoneId, err := controller.phonesUsecase.StorePhone(ctx, req.ToDomain(), id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.phoneAgentUsecase.Store(ctx, phoneId, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *PhonesController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        phone, err := controller.phonesUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(phone))</span>
}

func (controller *PhonesController) GetAll(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := middleware.GetUser(c).ID

        allPhone, err := controller.phoneAgentUsecase.GetAllByAgentID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">var phoneDomain []phones.Domain
        for _, value := range allPhone </span><span class="cov0" title="0">{
                phone, _ := controller.phonesUsecase.GetByID(ctx, value.PhoneID)
                phoneDomain = append(phoneDomain, phone)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromListDomain(phoneDomain))</span>
}

func (controller *PhonesController) DeletePhone(c echo.Context) error <span class="cov0" title="0">{
        phoneId, _ := strconv.Atoi(c.Param("id"))
        ctx := c.Request().Context()

        agentId := middleware.GetUser(c).ID

        err := controller.phoneAgentUsecase.Delete(ctx, agentId, phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.phonesUsecase.Delete(ctx, phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Delete Successfully")</span>
}

func (controller *PhonesController) UpdatePhone(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        phoneId, _ := strconv.Atoi(c.Param("id"))

        req := request.Phone{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">err := controller.phonesUsecase.Update(ctx, req.ToDomain(), phoneId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package request

import "go-drop-logistik/business/phones"

type Phone struct {
        Phone string `json:"phone"`
}

func (req *Phone) ToDomain() *phones.Domain <span class="cov0" title="0">{
        return &amp;phones.Domain{
                Phone: req.Phone,
        }
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package response

import (
        "go-drop-logistik/business/phones"
        "time"
)

type Phones struct {
        ID        int       `json:"id"`
        Phone     string    `json:"phone"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

func FromDomain(phoneDomain phones.Domain) Phones <span class="cov0" title="0">{
        return Phones{
                ID:        phoneDomain.ID,
                Phone:     phoneDomain.Phone,
                CreatedAt: phoneDomain.CreatedAt,
                UpdatedAt: phoneDomain.UpdatedAt,
        }
}</span>

func FromListDomain(agentDomain []phones.Domain) *[]Phones <span class="cov0" title="0">{
        allPhone := []Phones{}
        for _, value := range agentDomain </span><span class="cov0" title="0">{
                phone := Phones{
                        ID:        value.ID,
                        Phone:     value.Phone,
                        CreatedAt: value.CreatedAt,
                        UpdatedAt: value.UpdatedAt,
                }
                allPhone = append(allPhone, phone)
        }</span>

        <span class="cov0" title="0">return &amp;allPhone</span>
}</pre>
		
		<pre class="file" id="file35" style="display: none">package receipts

import (
        "net/http"
        "strconv"
        "sync"

        "go-drop-logistik/business/manifestreceipt"
        "go-drop-logistik/business/receipts"
        "go-drop-logistik/business/trackmanifest"
        "go-drop-logistik/controllers/receipts/request"
        "go-drop-logistik/controllers/receipts/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type ReceiptController struct {
        receiptUsecase         receipts.Usecase
        manifestreceiptUsecase manifestreceipt.Usecase
        trackManifestUsecase   trackmanifest.Usecase
}

func NewReceiptController(uc receipts.Usecase, mr manifestreceipt.Usecase, tr trackmanifest.Usecase) *ReceiptController <span class="cov0" title="0">{
        return &amp;ReceiptController{
                receiptUsecase:         uc,
                manifestreceiptUsecase: mr,
                trackManifestUsecase:   tr,
        }
}</span>

func (controller *ReceiptController) CreateReceipt(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Receipts{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">receiptId, err := controller.receiptUsecase.StoreReceipt(ctx, req.ToDomain())
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.manifestreceiptUsecase.Store(ctx, req.ManifestID, receiptId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *ReceiptController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        receipt, err := controller.receiptUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(receipt))</span>
}

func (controller *ReceiptController) GetByCode(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.TrackingReceipts{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">receipt, err := controller.receiptUsecase.GetByCode(ctx, req.Code)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">manifestId, err := controller.manifestreceiptUsecase.GetByReceiptID(ctx, receipt.ID)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">tracks, err := controller.trackManifestUsecase.GetAllByManifestID(ctx, manifestId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">wg := &amp;sync.WaitGroup{}
        
        wg.Add(len(tracks))
        go func() </span><span class="cov0" title="0">{
                for _, value := range tracks </span><span class="cov0" title="0">{
                        receipt.Tracks = append(receipt.Tracks, *value.Track)
                        wg.Done()
                }</span>
        }()
        <span class="cov0" title="0">wg.Wait()

        return base_response.NewSuccessResponse(c, response.TrackFromDomain(receipt))</span>
}

func (controller *ReceiptController) Fetch(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        page, _ := strconv.Atoi(c.QueryParam("page"))
        perpage, _ := strconv.Atoi(c.QueryParam("per_page"))

        receipts, count, err := controller.receiptUsecase.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromListDomain(receipts, count))</span>
}

func (controller *ReceiptController) Delete(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        err := controller.receiptUsecase.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.manifestreceiptUsecase.DeleteByReceipt(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Delete Successfully")</span>
}

func (controller *ReceiptController) Update(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        req := request.Receipts{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.receiptUsecase.Update(ctx, req.ToDomain(), id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package request

import (
        "go-drop-logistik/business/receipts"
        "time"
)

type Receipts struct {
        ManifestID      int       `json:"manifest_id"`
        Receiver        string    `json:"receiver"`
        PhoneReceiver   string    `json:"phone_receiver"`
        AddressReceiver string    `json:"address_receiver"`
        Sender          string    `json:"sender"`
        PhoneSender     string    `json:"phone_sender"`
        AddressSender   string    `json:"address_sender"`
        Weight          float64   `json:"weight"`
        Unit            string    `json:"unit"`
        Price           float64   `json:"price"`
        Amount          float64   `json:"amount"`
        Status          string    `json:"status"`
        PickupAt        time.Time `json:"pickup_at"`
}

type TrackingReceipts struct {
        Code string `json:"code"`
}

func (req *Receipts) ToDomain() *receipts.Domain <span class="cov0" title="0">{
        return &amp;receipts.Domain{
                ManifestID:      req.ManifestID,
                Receiver:        req.Receiver,
                PhoneReceiver:   req.PhoneReceiver,
                AddressReceiver: req.AddressReceiver,
                Sender:          req.Sender,
                PhoneSender:     req.PhoneSender,
                AddressSender:   req.AddressSender,
                Weight:          req.Weight,
                Unit:            req.Unit,
                Price:           req.Price,
                Amount:          req.Amount,
                Status:          req.Status,
                PickupAt:        req.PickupAt,
        }
}</span>

func (req *TrackingReceipts) TrackingReceiptToDomain() *receipts.Domain <span class="cov0" title="0">{
        return &amp;receipts.Domain{
                Code: req.Code,
        }
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package response

import (
        "go-drop-logistik/business/receipts"
        trackResp "go-drop-logistik/controllers/tracks/response"
        "time"
)

type Receipts struct {
        ID              int       `json:"id"`
        Code            string    `json:"code"`
        Receiver        string    `json:"receiver"`
        PhoneReceiver   string    `json:"phone_receiver"`
        AddressReceiver string    `json:"address_receiver"`
        Sender          string    `json:"sender"`
        PhoneSender     string    `json:"phone_sender"`
        AddressSender   string    `json:"address_sender"`
        Weight          float64   `json:"weight"`
        Unit            string    `json:"unit"`
        Price           float64   `json:"price"`
        Amount          float64   `json:"amount"`
        Status          string    `json:"status"`
        PickupAt        time.Time `json:"pickup_at"`
}

type TrackReceipts struct {
        ID              int                `json:"id"`
        Code            string             `json:"code"`
        Receiver        string             `json:"receiver"`
        PhoneReceiver   string             `json:"phone_receiver"`
        AddressReceiver string             `json:"address_receiver"`
        Sender          string             `json:"sender"`
        PhoneSender     string             `json:"phone_sender"`
        AddressSender   string             `json:"address_sender"`
        Weight          float64            `json:"weight"`
        Unit            string             `json:"unit"`
        Price           float64            `json:"price"`
        Amount          float64            `json:"amount"`
        Status          string             `json:"status"`
        Tracks          *[]trackResp.Track `json:"track"`
        PickupAt        time.Time          `json:"pickup_at"`
}

type ReceiptPageResponse struct {
        Receipts *[]Receipts `json:"receipts"`
        Total    int         `json:"total"`
}

func FromDomain(receiptDomain receipts.Domain) Receipts <span class="cov0" title="0">{
        return Receipts{
                ID:              receiptDomain.ID,
                Code:            receiptDomain.Code,
                Receiver:        receiptDomain.Receiver,
                Sender:          receiptDomain.Sender,
                PhoneReceiver:   receiptDomain.PhoneReceiver,
                PhoneSender:     receiptDomain.PhoneSender,
                AddressReceiver: receiptDomain.AddressReceiver,
                AddressSender:   receiptDomain.AddressSender,
                Weight:          receiptDomain.Weight,
                Unit:            receiptDomain.Unit,
                Price:           receiptDomain.Price,
                Amount:          receiptDomain.Amount,
                Status:          receiptDomain.Status,
                PickupAt:        receiptDomain.PickupAt,
        }
}</span>

func TrackFromDomain(receiptDomain receipts.TrackDomain) TrackReceipts <span class="cov0" title="0">{
        return TrackReceipts{
                ID:              receiptDomain.ID,
                Code:            receiptDomain.Code,
                Receiver:        receiptDomain.Receiver,
                Sender:          receiptDomain.Sender,
                PhoneReceiver:   receiptDomain.PhoneReceiver,
                PhoneSender:     receiptDomain.PhoneSender,
                AddressReceiver: receiptDomain.AddressReceiver,
                AddressSender:   receiptDomain.AddressSender,
                Weight:          receiptDomain.Weight,
                Unit:            receiptDomain.Unit,
                Price:           receiptDomain.Price,
                Amount:          receiptDomain.Amount,
                Status:          receiptDomain.Status,
                Tracks:          trackResp.FromListDomain(&amp;receiptDomain.Tracks),
                PickupAt:        receiptDomain.PickupAt,
        }
}</span>

func FromListDomain(receiptDomain []receipts.Domain, Count int) *ReceiptPageResponse <span class="cov0" title="0">{
        allReceipt := []Receipts{}
        for _, value := range receiptDomain </span><span class="cov0" title="0">{
                receipt := Receipts{
                        ID:              value.ID,
                        Code:            value.Code,
                        Receiver:        value.Receiver,
                        Sender:          value.Sender,
                        PhoneReceiver:   value.PhoneReceiver,
                        PhoneSender:     value.PhoneSender,
                        AddressReceiver: value.AddressReceiver,
                        AddressSender:   value.AddressSender,
                        Weight:          value.Weight,
                        Unit:            value.Unit,
                        Price:           value.Price,
                        Amount:          value.Amount,
                        Status:          value.Status,
                        PickupAt:        value.PickupAt,
                }
                allReceipt = append(allReceipt, receipt)
        }</span>
        <span class="cov0" title="0">result := ReceiptPageResponse{}
        result.Receipts = &amp;allReceipt
        result.Total = Count
        return &amp;result</span>
}

func FromManifestListDomain(receiptDomain *[]receipts.Domain) (res *[]Receipts) <span class="cov0" title="0">{
        if receiptDomain != nil </span><span class="cov0" title="0">{
                res = &amp;[]Receipts{}
                for _, value := range *receiptDomain </span><span class="cov0" title="0">{
                        receipt := Receipts{
                                ID:              value.ID,
                                Code:            value.Code,
                                Receiver:        value.Receiver,
                                Sender:          value.Sender,
                                PhoneReceiver:   value.PhoneReceiver,
                                PhoneSender:     value.PhoneSender,
                                AddressReceiver: value.AddressReceiver,
                                AddressSender:   value.AddressSender,
                                Weight:          value.Weight,
                                Unit:            value.Unit,
                                Price:           value.Price,
                                Amount:          value.Amount,
                                Status:          value.Status,
                                PickupAt:        value.PickupAt,
                        }
                        *res = append(*res, receipt)
                }</span>
        }
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package tracks

import (
        "net/http"
        "strconv"

        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/trackmanifest"
        "go-drop-logistik/business/tracks"
        "go-drop-logistik/controllers/tracks/request"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type TracksController struct {
        trackUsecase         tracks.Usecase
        trackManifestUsecase trackmanifest.Usecase
}

func NewTracksController(uc tracks.Usecase, tr trackmanifest.Usecase) *TracksController <span class="cov0" title="0">{
        return &amp;TracksController{
                trackUsecase:         uc,
                trackManifestUsecase: tr,
        }
}</span>

func (controller *TracksController) CreateTrack(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        name := middleware.GetUser(c).Name
        manifestId, _ := strconv.Atoi(c.Param("id"))

        req := request.Track{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">trackId, err := controller.trackUsecase.StoreTrack(ctx, req.ToDomain(), name)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err = controller.trackManifestUsecase.Store(ctx, manifestId, trackId)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package request

import "go-drop-logistik/business/tracks"

type Track struct {
        StartAgentID       int    `json:"start_agent_id"`
        CurrentAgentID     int    `json:"current_agent_id"`
        DestinationAgentID int    `json:"destination_agent_id"`
        Message            string `json:"message"`
}

func (req *Track) ToDomain() *tracks.Domain <span class="cov0" title="0">{
        return &amp;tracks.Domain{
                StartAgentID:       req.StartAgentID,
                CurrentAgentID:     req.CurrentAgentID,
                DestinationAgentID: req.DestinationAgentID,
                Message:            req.Message,
        }
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package response

import (
        "go-drop-logistik/business/tracks"
        agentResp "go-drop-logistik/controllers/agents/response"
)

type Track struct {
        StartAgent       *agentResp.TrackAgentResponse `json:"start_agent"`
        CurrentAgent     *agentResp.TrackAgentResponse `json:"current_agent"`
        DestinationAgent *agentResp.TrackAgentResponse `json:"destination_agent"`
        Message          string            `json:"message"`
}

func FromDomain(trackDomain tracks.Domain) Track <span class="cov0" title="0">{
        return Track{
                StartAgent:       agentResp.FromTrackDomain(trackDomain.StartAgent),
                CurrentAgent:     agentResp.FromTrackDomain(trackDomain.CurrentAgent),
                DestinationAgent: agentResp.FromTrackDomain(trackDomain.DestinationAgent),
                Message:          trackDomain.Message,
        }
}</span>

func FromListDomain(trackDomain *[]tracks.Domain) *[]Track <span class="cov0" title="0">{
        allTrack := []Track{}
        for _, value := range *trackDomain </span><span class="cov0" title="0">{
                manifest := Track{
                        StartAgent:       agentResp.FromTrackDomain(value.StartAgent),
                        CurrentAgent:     agentResp.FromTrackDomain(value.CurrentAgent),
                        DestinationAgent: agentResp.FromTrackDomain(value.DestinationAgent),
                        Message:          value.Message,
                }
                allTrack = append(allTrack, manifest)
        }</span>

        <span class="cov0" title="0">return &amp;allTrack</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package trucks

import (
        "net/http"
        "strconv"

        "go-drop-logistik/business/trucks"
        "go-drop-logistik/controllers/trucks/request"
        "go-drop-logistik/controllers/trucks/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type TrucksController struct {
        trucksUsecase trucks.Usecase
}

func NewTrucksController(uc trucks.Usecase) *TrucksController <span class="cov0" title="0">{
        return &amp;TrucksController{
                trucksUsecase: uc,
        }
}</span>

func (controller *TrucksController) StoreTruck(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Trucks{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.trucksUsecase.StoreTruck(ctx, req.ToDomain())
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *TrucksController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id, _ := strconv.Atoi(c.Param("id"))

        phone, err := controller.trucksUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, phone)</span>
}

func (controller *TrucksController) DeleteTruck(c echo.Context) error <span class="cov0" title="0">{
        id, _ := strconv.Atoi(c.Param("id"))
        ctx := c.Request().Context()

        err := controller.trucksUsecase.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Delete Successfully")</span>
}

func (controller *TrucksController) UpdateTruck(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()
        id, _ := strconv.Atoi(c.Param("id"))

        req := request.Trucks{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">err := controller.trucksUsecase.Update(ctx, req.ToDomain(), id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, "Update Successfully")</span>
}

func (controller *TrucksController) Fetch(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        page, _ := strconv.Atoi(c.QueryParam("page"))
        perpage, _ := strconv.Atoi(c.QueryParam("per_page"))

        agents, count, err := controller.trucksUsecase.Fetch(ctx, page, perpage)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromListDomain(agents, count))</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package request

import "go-drop-logistik/business/trucks"

type Trucks struct {
        Name         string `json:"name"`
        Type         string `json:"type"`
        LicensePlate string `json:"license_plate"`
}

func (req *Trucks) ToDomain() *trucks.Domain <span class="cov0" title="0">{
        return &amp;trucks.Domain{
                Name:         req.Name,
                Type:         req.Type,
                LicensePlate: req.LicensePlate,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package response

import (
        "go-drop-logistik/business/trucks"
)

type Trucks struct {
        ID           int    `json:"id"`
        Name         string `json:"name"`
        Type         string `json:"type"`
        LicensePlate string `json:"license_plate"`
}

type TrucksPageResponse struct {
        Trucks *[]Trucks `json:"trucks"`
        Total  int       `json:"total"`
}

func FromDomain(truckDomain *trucks.Domain) (res *Trucks) <span class="cov0" title="0">{
        if truckDomain != nil </span><span class="cov0" title="0">{
                res = &amp;Trucks{
                        ID:           truckDomain.ID,
                        Name:         truckDomain.Name,
                        Type:         truckDomain.Type,
                        LicensePlate: truckDomain.LicensePlate,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}

func FromListDomain(truckDomain []trucks.Domain, Count int) *TrucksPageResponse <span class="cov0" title="0">{
        allTrucks := []Trucks{}
        for _, value := range truckDomain </span><span class="cov0" title="0">{
                truck := Trucks{
                        ID:           value.ID,
                        Name:         value.Name,
                        Type:         value.Type,
                        LicensePlate: value.LicensePlate,
                }
                allTrucks = append(allTrucks, truck)
        }</span>
        <span class="cov0" title="0">result := TrucksPageResponse{}
        result.Trucks = &amp;allTrucks
        result.Total = Count
        return &amp;result</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package users

import (
        "net/http"

        "go-drop-logistik/app/middleware"
        "go-drop-logistik/business/users"
        "go-drop-logistik/controllers/users/request"
        "go-drop-logistik/controllers/users/response"
        base_response "go-drop-logistik/helper/response"

        echo "github.com/labstack/echo/v4"
)

type UserController struct {
        userUsecase users.Usecase
}

func NewUserController(uc users.Usecase) *UserController <span class="cov0" title="0">{
        return &amp;UserController{
                userUsecase: uc,
        }
}</span>

func (controller *UserController) Register(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        req := request.Users{}
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">err := controller.userUsecase.Register(ctx, req.ToDomain(), false)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">return base_response.NewSuccessInsertResponse(c, "Successfully inserted")</span>
}

func (controller *UserController) Login(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        var userLogin request.Users
        if err := c.Bind(&amp;userLogin); err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">token, err := controller.userUsecase.Login(ctx, userLogin.Email, userLogin.Password, false)

        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>
        <span class="cov0" title="0">result := struct {
                Token string `json:"token"`
        }{Token: token}

        return base_response.NewSuccessResponse(c, result)</span>
}

func (controller *UserController) GetByID(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        id := middleware.GetUser(c).ID
        
        user, err := controller.userUsecase.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return base_response.NewErrorResponse(c, http.StatusBadRequest, err)
        }</span>

        <span class="cov0" title="0">return base_response.NewSuccessResponse(c, response.FromDomain(user))</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package request

import (
        "go-drop-logistik/business/users"
)

type Users struct {
        Name     string `json:"name"`
        Password string `json:"password,omitempty"`
        Email    string `json:"email"`
}

func (req *Users) ToDomain() *users.Domain <span class="cov0" title="0">{
        return &amp;users.Domain{
                Name:     req.Name,
                Password: req.Password,
                Email:    req.Email,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package response

import (
        "go-drop-logistik/business/users"
)

type Users struct {
        ID    int    `gorm:"primary_key" json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

func FromDomain(userDomain users.Domain) Users <span class="cov0" title="0">{
        return Users{
                ID:    userDomain.ID,
                Name:  userDomain.Name,
                Email: userDomain.Email,
        }
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package admins

import (
        "context"
        "go-drop-logistik/business/admins"

        "gorm.io/gorm"
)

type mysqlAdminRepository struct {
        Conn *gorm.DB
}

func NewMySQLAdminRepository(conn *gorm.DB) admins.Repository <span class="cov0" title="0">{
        return &amp;mysqlAdminRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlAdminRepository) GetByID(ctx context.Context, id int) (admins.Domain, error) <span class="cov0" title="0">{
        adminsById := Admins{}
        result := repository.Conn.Where("admins.id = ?", id).First(&amp;adminsById)
        if result.Error != nil </span><span class="cov0" title="0">{
                return admins.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *adminsById.ToDomain(), nil</span>
}

func (repository *mysqlAdminRepository) GetByEmail(ctx context.Context, email string) (admins.Domain, error) <span class="cov0" title="0">{
        rec := Admins{}

        err := repository.Conn.Where("admins.email = ?", email).First(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return admins.Domain{}, err
        }</span>

        <span class="cov0" title="0">return *rec.ToDomain(), nil</span>
}

func (repository *mysqlAdminRepository) Register(ctx context.Context, adminDomain *admins.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*adminDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package admins

import (
        "go-drop-logistik/business/admins"
        "time"
)

type Admins struct {
        ID        int `gorm:"primary_key"`
        Name      string
        Password  string
        Email     string
        Roles     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (rec *Admins) ToDomain() *admins.Domain <span class="cov0" title="0">{
        return &amp;admins.Domain{
                ID:        rec.ID,
                Name:      rec.Name,
                Password:  rec.Password,
                Email:     rec.Email,
                Roles:     rec.Roles,
                CreatedAt: rec.CreatedAt,
                UpdatedAt: rec.UpdatedAt,
        }
}</span>

func fromDomain(adminDomain admins.Domain) *Admins <span class="cov0" title="0">{
        return &amp;Admins{
                ID:        adminDomain.ID,
                Name:      adminDomain.Name,
                Password:  adminDomain.Password,
                Email:     adminDomain.Email,
                Roles:     adminDomain.Roles,
                CreatedAt: adminDomain.CreatedAt,
                UpdatedAt: adminDomain.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package agents

import (
        "context"
        "go-drop-logistik/business/agents"

        "gorm.io/gorm"
)

type mysqlAgentRepository struct {
        Conn *gorm.DB
}

func NewMySQLAgentRepository(conn *gorm.DB) agents.Repository <span class="cov0" title="0">{
        return &amp;mysqlAgentRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlAgentRepository) GetByID(ctx context.Context, id int) (agents.Domain, error) <span class="cov0" title="0">{
        agentById := Agents{}
        result := repository.Conn.Where("agents.id = ?", id).First(&amp;agentById)
        if result.Error != nil </span><span class="cov0" title="0">{
                return agents.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *agentById.ToDomain(), nil</span>
}

func (repository *mysqlAgentRepository) GetByEmail(ctx context.Context, email string) (agents.ExistingDomain, error) <span class="cov0" title="0">{
        rec := Agents{}

        err := repository.Conn.Where("agents.email = ?", email).First(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return agents.ExistingDomain{}, err
        }</span>

        <span class="cov0" title="0">return *rec.ToExistingDomain(), nil</span>
}

func (repository *mysqlAgentRepository) Register(ctx context.Context, agentDomain *agents.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*agentDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlAgentRepository) Fetch(ctx context.Context, page, perpage int) ([]agents.Domain, int, error) <span class="cov0" title="0">{
        rec := []Agents{}

        offset := (page - 1) * perpage
        err := repository.Conn.Offset(offset).Limit(perpage).Find(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return []agents.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var totalData int64
        err = repository.Conn.Model(&amp;rec).Count(&amp;totalData).Error
        if err != nil </span><span class="cov0" title="0">{
                return []agents.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var result []agents.Domain
        for _, value := range rec </span><span class="cov0" title="0">{
                result = append(result, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return result, int(totalData), nil</span>
}

func (repository *mysqlAgentRepository) Update(ctx context.Context, userDomain *agents.Domain, id int) error <span class="cov0" title="0">{
        agentUpdate := fromDomain(*userDomain)

        result := repository.Conn.Where("users.id = ?", id).Updates(&amp;agentUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file50" style="display: none">package agents

import (
        "go-drop-logistik/business/agents"
        "time"
)

type Agents struct {
        ID        int `gorm:"primary_key"`
        Name      string
        Password  string
        Email     string
        Roles     string
        Address   string
        Balance   float64
        Latitude  float64
        Longitude float64
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (rec *Agents) ToExistingDomain() *agents.ExistingDomain <span class="cov0" title="0">{
        return &amp;agents.ExistingDomain{
                ID:        rec.ID,
                Password:  rec.Password,
                Name:      rec.Name,
                Email:     rec.Email,
                Roles:     rec.Roles,
                CreatedAt: rec.CreatedAt,
                UpdatedAt: rec.UpdatedAt,
        }
}</span>

func (rec *Agents) ToDomain() (res *agents.Domain) <span class="cov0" title="0">{
        if rec != nil </span><span class="cov0" title="0">{
                res = &amp;agents.Domain{
                        ID:        rec.ID,
                        Name:      rec.Name,
                        Password:  rec.Password,
                        Email:     rec.Email,
                        Roles:     rec.Roles,
                        Address:   rec.Address,
                        Balance:   rec.Balance,
                        Latitude:  rec.Latitude,
                        Longitude: rec.Longitude,
                        CreatedAt: rec.CreatedAt,
                        UpdatedAt: rec.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}

func fromDomain(agentDomain agents.Domain) *Agents <span class="cov0" title="0">{
        return &amp;Agents{
                ID:        agentDomain.ID,
                Name:      agentDomain.Name,
                Password:  agentDomain.Password,
                Email:     agentDomain.Email,
                Roles:     agentDomain.Roles,
                Address:   agentDomain.Address,
                Balance:   agentDomain.Balance,
                Latitude:  agentDomain.Latitude,
                Longitude: agentDomain.Longitude,
                CreatedAt: agentDomain.CreatedAt,
                UpdatedAt: agentDomain.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package drivers

import (
        "context"
        "go-drop-logistik/business/drivers"

        "gorm.io/gorm"
)

type mysqlDriverRepository struct {
        Conn *gorm.DB
}

func NewMySQLDriverRepository(conn *gorm.DB) drivers.Repository <span class="cov0" title="0">{
        return &amp;mysqlDriverRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlDriverRepository) Store(ctx context.Context, driverDomain *drivers.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*driverDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlDriverRepository) GetByID(ctx context.Context, id int) (drivers.Domain, error) <span class="cov0" title="0">{
        phone := Drivers{}
        result := repository.Conn.Preload("Truck").Where("id = ?", id).First(&amp;phone)
        if result.Error != nil </span><span class="cov0" title="0">{
                return drivers.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *phone.ToDomain(), nil</span>
}

func (repository *mysqlDriverRepository) Update(ctx context.Context, phoneDomain *drivers.Domain, id int) error <span class="cov0" title="0">{
        phoneUpdate := fromDomain(*phoneDomain)

        result := repository.Conn.Preload("Truck").Where("id = ?", id).Updates(&amp;phoneUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlDriverRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        phoneDelete := Drivers{}
        result := repository.Conn.Preload("Truck").Where("id = ?", id).Delete(&amp;phoneDelete)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package drivers

import (
        "go-drop-logistik/business/drivers"
        "go-drop-logistik/drivers/databases/trucks"
)

type Drivers struct {
        ID      int `gorm:"primary_key"`
        Name    string
        Phone   string
        Address string
        TruckID int
        Truck   *trucks.Trucks `gorm:"foreignkey:TruckID;references:ID"`
}

func fromDomain(driverDomain drivers.Domain) *Drivers <span class="cov0" title="0">{
        return &amp;Drivers{
                ID:      driverDomain.ID,
                Name:    driverDomain.Name,
                Phone:   driverDomain.Phone,
                Address: driverDomain.Address,
                TruckID: driverDomain.TruckID,
        }
}</span>

func (rec *Drivers) ToDomain() *drivers.Domain <span class="cov0" title="0">{
        return &amp;drivers.Domain{
                ID:      rec.ID,
                Name:    rec.Name,
                Phone:   rec.Phone,
                Address: rec.Address,
                TruckID: rec.TruckID,
                Truck:   rec.Truck.ToDomain(),
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package manifest

import (
        "context"
        "go-drop-logistik/business/manifest"

        "gorm.io/gorm"
)

type mysqlManifestRepository struct {
        Conn *gorm.DB
}

func NewMySQLManifestRepository(conn *gorm.DB) manifest.Repository <span class="cov0" title="0">{
        return &amp;mysqlManifestRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlManifestRepository) StoreManifest(ctx context.Context, manifestDomain *manifest.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*manifestDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlManifestRepository) GetByID(ctx context.Context, id int) (manifest.Domain, error) <span class="cov0" title="0">{
        rec := Manifest{}
        result := repository.Conn.Preload("Driver").Preload("Driver.Truck").Where("id = ?", id).First(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return manifest.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *rec.ToDomain(), nil</span>
}

func (repository *mysqlManifestRepository) Fetch(ctx context.Context, page, perpage int) ([]manifest.Domain, int, error) <span class="cov0" title="0">{
        rec := []Manifest{}

        offset := (page - 1) * perpage
        err := repository.Conn.Preload("Driver").Preload("Driver.Truck").Offset(offset).Limit(perpage).Find(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return []manifest.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var totalData int64
        err = repository.Conn.Model(&amp;rec).Count(&amp;totalData).Error
        if err != nil </span><span class="cov0" title="0">{
                return []manifest.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var result []manifest.Domain
        for _, value := range rec </span><span class="cov0" title="0">{
                result = append(result, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return result, int(totalData), nil</span>
}

func (repository *mysqlManifestRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        rec := Manifest{}
        result := repository.Conn.Where("id = ?", id).Delete(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlManifestRepository) Update(ctx context.Context, manifestDomain *manifest.Domain, id int) error <span class="cov0" title="0">{
        manifestUpdate := fromDomain(*manifestDomain)

        result := repository.Conn.Where("id = ?", id).Updates(&amp;manifestUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package manifest

import (
        "go-drop-logistik/business/manifest"
        "go-drop-logistik/drivers/databases/drivers"
        "time"

        "gorm.io/gorm"
)

type Manifest struct {
        ID        int `gorm:"primary_key"`
        Code      string
        Status    string
        DriverID  int
        Driver    *drivers.Drivers `gorm:"foreignkey:DriverID;references:ID"`
        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt gorm.DeletedAt
}

func (rec *Manifest) ToDomain() (res *manifest.Domain) <span class="cov0" title="0">{
        if rec != nil </span><span class="cov0" title="0">{
                res = &amp;manifest.Domain{
                        ID:        rec.ID,
                        Code:      rec.Code,
                        Status:    rec.Status,
                        DriverID:  rec.DriverID,
                        Driver:    rec.Driver.ToDomain(),
                        CreatedAt: rec.CreatedAt,
                        UpdatedAt: rec.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}

func fromDomain(manifestDomain manifest.Domain) *Manifest <span class="cov0" title="0">{
        return &amp;Manifest{
                ID:        manifestDomain.ID,
                Code:      manifestDomain.Code,
                Status:    manifestDomain.Status,
                DriverID:  manifestDomain.DriverID,
                CreatedAt: manifestDomain.CreatedAt,
                UpdatedAt: manifestDomain.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package manifestreceipt

import (
        "context"
        "go-drop-logistik/business/manifestreceipt"

        "gorm.io/gorm"
)

type mysqlManifestReceiptRepository struct {
        Conn *gorm.DB
}

func NewMySQLManifestReceiptRepository(conn *gorm.DB) manifestreceipt.Repository <span class="cov0" title="0">{
        return &amp;mysqlManifestReceiptRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlManifestReceiptRepository) Store(ctx context.Context, manifestId, ReceiptId int) error <span class="cov0" title="0">{
        manifestReceipt := &amp;manifestreceipt.Domain{
                ManifestID: manifestId,
                ReceiptID:  ReceiptId,
        }

        rec := fromDomain(*manifestReceipt)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlManifestReceiptRepository) GetByManifestID(ctx context.Context, id int) (manifestreceipt.Domain, error) <span class="cov0" title="0">{
        manifestReceipt := ManifestReceipt{}
        result := repository.Conn.Preload("Receipt").Where("manifest_id = ?", id).First(&amp;manifestReceipt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return manifestreceipt.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *manifestReceipt.ToDomain(), nil</span>
}

func (repository *mysqlManifestReceiptRepository) GetByReceiptID(ctx context.Context, id int) (int, error) <span class="cov0" title="0">{
        manifestReceipt := ManifestReceipt{}
        result := repository.Conn.Where("receipt_id = ?", id).First(&amp;manifestReceipt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return manifestReceipt.ManifestID, nil</span>
}

func (repository *mysqlManifestReceiptRepository) GetAllByManifestID(ctx context.Context, id int) ([]manifestreceipt.Domain, error) <span class="cov0" title="0">{
        allManifestReceipt := []ManifestReceipt{}

        result := repository.Conn.Preload("Receipt").Where("manifest_id = ?", id).Find(&amp;allManifestReceipt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return []manifestreceipt.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">allManifestReceiptDomain := []manifestreceipt.Domain{}
        for _, value := range allManifestReceipt </span><span class="cov0" title="0">{
                allManifestReceiptDomain = append(allManifestReceiptDomain, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return allManifestReceiptDomain, nil</span>
}

func (repository *mysqlManifestReceiptRepository) DeleteByReceipt(ctx context.Context, ReceiptId int) error <span class="cov0" title="0">{
        manifestReceipt := ManifestReceipt{}
        result := repository.Conn.Preload("Receipt").Preload("Manifest").Where("receipt_id = ?", ReceiptId).Delete(&amp;manifestReceipt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}


func (repository *mysqlManifestReceiptRepository) DeleteByManifest(ctx context.Context, manifestId int) error <span class="cov0" title="0">{
        manifestReceipt := ManifestReceipt{}
        result := repository.Conn.Preload("Receipt").Preload("Manifest").Where("manifest_id = ?", manifestId).Delete(&amp;manifestReceipt)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package manifestreceipt

import (
        "go-drop-logistik/business/manifestreceipt"
        "go-drop-logistik/drivers/databases/manifest"
        "go-drop-logistik/drivers/databases/receipts"
)

type ManifestReceipt struct {
        ManifestID int
        Manifest   *manifest.Manifest `gorm:"foreignkey:ManifestID;references:ID"`
        ReceiptID  int
        Receipt    *receipts.Receipts `gorm:"foreignkey:ReceiptID;references:ID"`
}

func fromDomain(manifestReceiptDomain manifestreceipt.Domain) *ManifestReceipt <span class="cov0" title="0">{
        return &amp;ManifestReceipt{
                ManifestID: manifestReceiptDomain.ManifestID,
                ReceiptID:  manifestReceiptDomain.ReceiptID,
        }
}</span>

func (rec *ManifestReceipt) ToDomain() *manifestreceipt.Domain <span class="cov0" title="0">{
        return &amp;manifestreceipt.Domain{
                ManifestID: rec.ManifestID,
                Manifest:   rec.Manifest.ToDomain(),
                ReceiptID:  rec.ReceiptID,
                Receipt:    rec.Receipt.ToDomain(),
        }
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package phoneagent

import (
        "context"
        "go-drop-logistik/business/phoneagent"

        "gorm.io/gorm"
)

type mysqlPhoneAgentRepository struct {
        Conn *gorm.DB
}

func NewMySQLPhoneAgentRepository(conn *gorm.DB) phoneagent.Repository <span class="cov0" title="0">{
        return &amp;mysqlPhoneAgentRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlPhoneAgentRepository) Store(ctx context.Context, phoneId, agentId int) error <span class="cov0" title="0">{
        phoneAgent := &amp;phoneagent.Domain{
                PhoneID: phoneId,
                AgentID: agentId,
        }

        rec := fromDomain(*phoneAgent)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlPhoneAgentRepository) GetByAgentID(ctx context.Context, id int) (phoneagent.Domain, error) <span class="cov0" title="0">{
        phoneAgent := PhoneAgent{}
        result := repository.Conn.Preload("Phone").Where("agent_id = ?", id).First(&amp;phoneAgent)
        if result.Error != nil </span><span class="cov0" title="0">{
                return phoneagent.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *phoneAgent.ToDomain(), nil</span>
}

func (repository *mysqlPhoneAgentRepository) GetAllByAgentID(ctx context.Context, id int) ([]phoneagent.Domain, error) <span class="cov0" title="0">{
        allPhoneAgent := []PhoneAgent{}
        result := repository.Conn.Preload("Phone").Where("agent_id = ?", id).Find(&amp;allPhoneAgent)
        if result.Error != nil </span><span class="cov0" title="0">{
                return []phoneagent.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">allPhoneAgentDomain := []phoneagent.Domain{}
        for _, value := range allPhoneAgent </span><span class="cov0" title="0">{
                allPhoneAgentDomain = append(allPhoneAgentDomain, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return allPhoneAgentDomain, nil</span>
}

func (repository *mysqlPhoneAgentRepository) Delete(ctx context.Context, agentId, phoneId int) error <span class="cov0" title="0">{
        phoneDelete := PhoneAgent{}
        result := repository.Conn.Preload("Phone").Preload("Agent").Where("agent_id = ?", agentId).Where("phone_id = ?", phoneId).Delete(&amp;phoneDelete)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package phoneagent

import (
        "go-drop-logistik/business/phoneagent"
        "go-drop-logistik/drivers/databases/agents"
        "go-drop-logistik/drivers/databases/phones"
)

type PhoneAgent struct {
        PhoneID int
        Phone   *phones.Phones `gorm:"foreignkey:PhoneID;references:ID"`
        AgentID int
        Agent   *agents.Agents `gorm:"foreignkey:AgentID;references:ID"`
}

func fromDomain(phoneAgentDomain phoneagent.Domain) *PhoneAgent <span class="cov0" title="0">{
        return &amp;PhoneAgent{
                PhoneID: phoneAgentDomain.PhoneID,
                AgentID: phoneAgentDomain.AgentID,
        }
}</span>

func (rec *PhoneAgent) ToDomain() *phoneagent.Domain <span class="cov0" title="0">{
        return &amp;phoneagent.Domain{
                PhoneID: rec.PhoneID,
                Phone:   rec.Phone.ToDomain(),
                AgentID: rec.AgentID,
                Agent:   rec.Agent.ToDomain(),
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package phones

import (
        "context"
        "go-drop-logistik/business/phones"

        "gorm.io/gorm"
)

type mysqlPhoneRepository struct {
        Conn *gorm.DB
}

func NewMySQLPhoneRepository(conn *gorm.DB) phones.Repository <span class="cov0" title="0">{
        return &amp;mysqlPhoneRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlPhoneRepository) StorePhone(ctx context.Context, phoneDomain *phones.Domain) (int, error) <span class="cov0" title="0">{
        rec := fromDomain(*phoneDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>

        <span class="cov0" title="0">return rec.ID, nil</span>
}

func (repository *mysqlPhoneRepository) GetByID(ctx context.Context, id int) (phones.Domain, error) <span class="cov0" title="0">{
        phone := Phones{}
        result := repository.Conn.Where("id = ?", id).First(&amp;phone)
        if result.Error != nil </span><span class="cov0" title="0">{
                return phones.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *phone.ToDomain(), nil</span>
}

func (repository *mysqlPhoneRepository) GetAll(ctx context.Context) ([]phones.Domain, error) <span class="cov0" title="0">{
        rec := []Phones{}
        result := repository.Conn.Find(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return []phones.Domain{}, result.Error
        }</span>
        <span class="cov0" title="0">phoneDomain := []phones.Domain{}
        for _, value := range rec </span><span class="cov0" title="0">{
                phoneDomain = append(phoneDomain, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return phoneDomain, nil</span>
}


func (repository *mysqlPhoneRepository) Update(ctx context.Context, phoneDomain *phones.Domain, id int) error <span class="cov0" title="0">{
        phoneUpdate := fromDomain(*phoneDomain)

        result := repository.Conn.Where("id = ?", id).Updates(&amp;phoneUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlPhoneRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        phoneDelete := Phones{}
        result := repository.Conn.Where("id = ?", id).Delete(&amp;phoneDelete)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package phones

import (
        "go-drop-logistik/business/phones"
        "time"

        "gorm.io/gorm"
)

type Phones struct {
        ID        int `gorm:"primary_key"`
        Phone     string
        CreatedAt time.Time
        UpdatedAt time.Time
        DeletedAt gorm.DeletedAt
}

func fromDomain(phoneDomain phones.Domain) *Phones <span class="cov0" title="0">{
        return &amp;Phones{
                ID:        phoneDomain.ID,
                Phone:     phoneDomain.Phone,
                CreatedAt: phoneDomain.CreatedAt,
                UpdatedAt: phoneDomain.UpdatedAt,
        }
}</span>

func (rec *Phones) ToDomain() (res *phones.Domain) <span class="cov0" title="0">{
        if rec != nil </span><span class="cov0" title="0">{
                res = &amp;phones.Domain{
                        ID:        rec.ID,
                        Phone:     rec.Phone,
                        CreatedAt: rec.CreatedAt,
                        UpdatedAt: rec.UpdatedAt,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package receipts

import (
        "context"
        "go-drop-logistik/business/receipts"

        "gorm.io/gorm"
)

type mysqlReceiptRepository struct {
        Conn *gorm.DB
}

func NewMySQLReceiptRepository(conn *gorm.DB) receipts.Repository <span class="cov0" title="0">{
        return &amp;mysqlReceiptRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlReceiptRepository) StoreReceipt(ctx context.Context, receiptDomain *receipts.Domain) (int, error) <span class="cov0" title="0">{
        rec := fromDomain(*receiptDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>
        <span class="cov0" title="0">return rec.ID, nil</span>
}

func (repository *mysqlReceiptRepository) GetByID(ctx context.Context, id int) (receipts.Domain, error) <span class="cov0" title="0">{
        rec := Receipts{}
        result := repository.Conn.Where("receipts.id = ?", id).First(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return receipts.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *rec.ToDomain(), nil</span>
}

func (repository *mysqlReceiptRepository) GetByCode(ctx context.Context, code string) (receipts.TrackDomain, error) <span class="cov0" title="0">{
        rec := Receipts{}
        result := repository.Conn.Where("receipts.code = ?", code).First(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return receipts.TrackDomain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *rec.TrackToDomain(), nil</span>
}

func (repository *mysqlReceiptRepository) Fetch(ctx context.Context, page, perpage int) ([]receipts.Domain, int, error) <span class="cov0" title="0">{
        rec := []Receipts{}

        offset := (page - 1) * perpage
        err := repository.Conn.Offset(offset).Limit(perpage).Find(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return []receipts.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var totalData int64
        err = repository.Conn.Model(&amp;rec).Count(&amp;totalData).Error
        if err != nil </span><span class="cov0" title="0">{
                return []receipts.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var result []receipts.Domain
        for _, value := range rec </span><span class="cov0" title="0">{
                result = append(result, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return result, int(totalData), nil</span>
}

func (repository *mysqlReceiptRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        rec := Receipts{}
        result := repository.Conn.Where("id = ?", id).Delete(&amp;rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlReceiptRepository) Update(ctx context.Context, receiptDomain *receipts.Domain, id int) error <span class="cov0" title="0">{
        receiptUpdate := fromDomain(*receiptDomain)

        result := repository.Conn.Where("id = ?", id).Updates(&amp;receiptUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package receipts

import (
        "go-drop-logistik/business/receipts"
        "time"

        "gorm.io/gorm"
)

type Receipts struct {
        ID              int `gorm:"primary_key"`
        Code            string
        Receiver        string
        PhoneReceiver   string
        AddressReceiver string
        Sender          string
        PhoneSender     string
        AddressSender   string
        Weight          float64
        Unit            string
        Price           float64
        Amount          float64
        Status          string
        PickupAt        time.Time
        CreatedAt       time.Time
        UpdatedAt       time.Time
        DeletedAt       gorm.DeletedAt
}

func (rec *Receipts) ToDomain() *receipts.Domain <span class="cov0" title="0">{
        return &amp;receipts.Domain{
                ID:              rec.ID,
                Code:            rec.Code,
                Receiver:        rec.Receiver,
                PhoneReceiver:   rec.PhoneReceiver,
                AddressReceiver: rec.AddressReceiver,
                Sender:          rec.Sender,
                PhoneSender:     rec.PhoneSender,
                AddressSender:   rec.AddressSender,
                Weight:          rec.Weight,
                Unit:            rec.Unit,
                Price:           rec.Price,
                Amount:          rec.Amount,
                Status:          rec.Status,
                PickupAt:        rec.PickupAt,
                CreatedAt:       rec.CreatedAt,
                UpdatedAt:       rec.UpdatedAt,
        }
}</span>

func (rec *Receipts) TrackToDomain() *receipts.TrackDomain <span class="cov0" title="0">{
        return &amp;receipts.TrackDomain{
                ID:              rec.ID,
                Code:            rec.Code,
                Receiver:        rec.Receiver,
                PhoneReceiver:   rec.PhoneReceiver,
                AddressReceiver: rec.AddressReceiver,
                Sender:          rec.Sender,
                PhoneSender:     rec.PhoneSender,
                AddressSender:   rec.AddressSender,
                Weight:          rec.Weight,
                Unit:            rec.Unit,
                Price:           rec.Price,
                Amount:          rec.Amount,
                Status:          rec.Status,
                PickupAt:        rec.PickupAt,
                CreatedAt:       rec.CreatedAt,
                UpdatedAt:       rec.UpdatedAt,
        }
}</span>

func fromDomain(receiptDomain receipts.Domain) *Receipts <span class="cov0" title="0">{
        return &amp;Receipts{
                ID:              receiptDomain.ID,
                Code:            receiptDomain.Code,
                Receiver:        receiptDomain.Receiver,
                PhoneReceiver:   receiptDomain.PhoneReceiver,
                AddressReceiver: receiptDomain.AddressReceiver,
                Sender:          receiptDomain.Sender,
                PhoneSender:     receiptDomain.PhoneSender,
                AddressSender:   receiptDomain.AddressSender,
                Weight:          receiptDomain.Weight,
                Unit:            receiptDomain.Unit,
                Price:           receiptDomain.Price,
                Amount:          receiptDomain.Amount,
                Status:          receiptDomain.Status,
                PickupAt:        receiptDomain.PickupAt,
                CreatedAt:       receiptDomain.CreatedAt,
                UpdatedAt:       receiptDomain.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package trackmanifest

import (
        "context"
        "go-drop-logistik/business/trackmanifest"

        "gorm.io/gorm"
)

type mysqlTrackManifestRepository struct {
        Conn *gorm.DB
}

func NewMySQLTrackManifestRepository(conn *gorm.DB) trackmanifest.Repository <span class="cov0" title="0">{
        return &amp;mysqlTrackManifestRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlTrackManifestRepository) Store(ctx context.Context, manifestId, trackId int) error <span class="cov0" title="0">{
        trackManifest := &amp;trackmanifest.Domain{
                ManifestID: manifestId,
                TrackID:    trackId,
        }

        rec := fromDomain(*trackManifest)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlTrackManifestRepository) GetByManifestID(ctx context.Context, id int) (trackmanifest.Domain, error) <span class="cov0" title="0">{
        trackManifest := TrackManifest{}
        result := repository.Conn.Where("manifest_id = ?", id).First(&amp;trackManifest)
        if result.Error != nil </span><span class="cov0" title="0">{
                return trackmanifest.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *trackManifest.ToDomain(), nil</span>
}

func (repository *mysqlTrackManifestRepository) GetAllByManifestID(ctx context.Context, id int) ([]trackmanifest.Domain, error) <span class="cov0" title="0">{
        allTrackManifest := []TrackManifest{}

        result := repository.Conn.Preload("Track.StartAgent").Preload("Track.CurrentAgent").Preload("Track.DestinationAgent").Where("manifest_id = ?", id).Find(&amp;allTrackManifest)
        if result.Error != nil </span><span class="cov0" title="0">{
                return []trackmanifest.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">allTrackManifestDomain := []trackmanifest.Domain{}
        for _, value := range allTrackManifest </span><span class="cov0" title="0">{
                allTrackManifestDomain = append(allTrackManifestDomain, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return allTrackManifestDomain, nil</span>
}
func (repository *mysqlTrackManifestRepository) DeleteByManifest(ctx context.Context, manifestId int) error <span class="cov0" title="0">{
        trackManifest := TrackManifest{}
        result := repository.Conn.Preload("Track").Preload("Manifest").Where("manifest_id = ?", manifestId).Delete(&amp;trackManifest)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package trackmanifest

import (
        "go-drop-logistik/business/trackmanifest"
        "go-drop-logistik/drivers/databases/manifest"
        "go-drop-logistik/drivers/databases/tracks"
)

type TrackManifest struct {
        TrackID    int
        Track      *tracks.Tracks `gorm:"foreignkey:TrackID;references:ID"`
        ManifestID int
        Manifest   *manifest.Manifest `gorm:"foreignkey:ManifestID;references:ID"`
}

func fromDomain(trackManifestDomain trackmanifest.Domain) *TrackManifest <span class="cov0" title="0">{
        return &amp;TrackManifest{
                TrackID:    trackManifestDomain.TrackID,
                ManifestID: trackManifestDomain.ManifestID,
        }
}</span>

func (rec *TrackManifest) ToDomain() *trackmanifest.Domain <span class="cov0" title="0">{
        return &amp;trackmanifest.Domain{
                TrackID:    rec.TrackID,
                Track:      rec.Track.ToDomain(),
                ManifestID: rec.ManifestID,
                Manifest:   rec.Manifest.ToDomain(),
        }
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package tracks

import (
        "context"
        "go-drop-logistik/business/tracks"

        "gorm.io/gorm"
)

type mysqlTrackRepository struct {
        Conn *gorm.DB
}

func NewMySQLTrackRepository(conn *gorm.DB) tracks.Repository <span class="cov0" title="0">{
        return &amp;mysqlTrackRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlTrackRepository) StoreTrack(ctx context.Context, trackDomain *tracks.Domain) (int, error) <span class="cov0" title="0">{
        rec := fromDomain(*trackDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return 0, result.Error
        }</span>
        <span class="cov0" title="0">return rec.ID, nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package tracks

import (
        "go-drop-logistik/business/tracks"
        "go-drop-logistik/drivers/databases/agents"
        "time"

        "gorm.io/gorm"
)

type Tracks struct {
        ID                 int `gorm:"primary_key"`
        StartAgentID       int
        StartAgent         *agents.Agents `gorm:"foreignkey:StartAgentID;references:ID"`
        CurrentAgentID     int
        CurrentAgent       *agents.Agents `gorm:"foreignkey:CurrentAgentID;references:ID"`
        DestinationAgentID int
        DestinationAgent   *agents.Agents `gorm:"foreignkey:DestinationAgentID;references:ID"`
        Message            string
        CreatedAt          time.Time
        DeletedAt          gorm.DeletedAt
}

func (rec *Tracks) ToDomain() (res *tracks.Domain) <span class="cov0" title="0">{
        if rec != nil </span><span class="cov0" title="0">{
                res = &amp;tracks.Domain{
                        ID:                 rec.ID,
                        StartAgentID:       rec.StartAgentID,
                        StartAgent:         rec.StartAgent.ToDomain(),
                        CurrentAgentID:     rec.CurrentAgentID,
                        CurrentAgent:       rec.CurrentAgent.ToDomain(),
                        DestinationAgentID: rec.DestinationAgentID,
                        DestinationAgent:   rec.DestinationAgent.ToDomain(),
                        Message:            rec.Message,
                        CreatedAt:          rec.CreatedAt,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}


func fromDomain(trackDomain tracks.Domain) *Tracks <span class="cov0" title="0">{
        return &amp;Tracks{
                ID:                 trackDomain.ID,
                StartAgentID:       trackDomain.StartAgentID,
                CurrentAgentID:     trackDomain.CurrentAgentID,
                DestinationAgentID: trackDomain.DestinationAgentID,
                Message:            trackDomain.Message,
                CreatedAt:          trackDomain.CreatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package trucks

import (
        "context"
        "go-drop-logistik/business/trucks"

        "gorm.io/gorm"
)

type mysqlTruckRepository struct {
        Conn *gorm.DB
}

func NewMySQLTruckRepository(conn *gorm.DB) trucks.Repository <span class="cov0" title="0">{
        return &amp;mysqlTruckRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlTruckRepository) StoreTruck(ctx context.Context, truckDomain *trucks.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*truckDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlTruckRepository) GetByID(ctx context.Context, id int) (trucks.Domain, error) <span class="cov0" title="0">{
        truck := Trucks{}
        result := repository.Conn.Where("id = ?", id).First(&amp;truck)
        if result.Error != nil </span><span class="cov0" title="0">{
                return trucks.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *truck.ToDomain(), nil</span>
}

func (repository *mysqlTruckRepository) Update(ctx context.Context, truckDomain *trucks.Domain, id int) error <span class="cov0" title="0">{
        truckUpdate := fromDomain(*truckDomain)

        result := repository.Conn.Where("id = ?", id).Updates(&amp;truckUpdate)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlTruckRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        truckDelete := Trucks{}
        result := repository.Conn.Where("id = ?", id).Delete(&amp;truckDelete)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (repository *mysqlTruckRepository) Fetch(ctx context.Context, page, perpage int) ([]trucks.Domain, int, error) <span class="cov0" title="0">{
        rec := []Trucks{}

        offset := (page - 1) * perpage
        err := repository.Conn.Offset(offset).Limit(perpage).Find(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return []trucks.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var totalData int64
        err = repository.Conn.Model(&amp;rec).Count(&amp;totalData).Error
        if err != nil </span><span class="cov0" title="0">{
                return []trucks.Domain{}, 0, err
        }</span>

        <span class="cov0" title="0">var result []trucks.Domain
        for _, value := range rec </span><span class="cov0" title="0">{
                result = append(result, *value.ToDomain())
        }</span>

        <span class="cov0" title="0">return result, int(totalData), nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package trucks

import (
        "go-drop-logistik/business/trucks"
        "time"
)

type Trucks struct {
        ID           int `gorm:"primary_key"`
        Name         string
        Type         string
        LicensePlate string
        CreatedAt    time.Time
}

func fromDomain(truckDomain trucks.Domain) *Trucks <span class="cov0" title="0">{
        return &amp;Trucks{
                ID:           truckDomain.ID,
                Name:         truckDomain.Name,
                Type:         truckDomain.Type,
                LicensePlate: truckDomain.LicensePlate,
                CreatedAt:    truckDomain.CreatedAt,
        }
}</span>

func (rec *Trucks) ToDomain() (res *trucks.Domain) <span class="cov0" title="0">{
        if rec != nil </span><span class="cov0" title="0">{
                res = &amp;trucks.Domain{
                        ID:        rec.ID,
                        Name:      rec.Name,
                        Type:      rec.Type,
                        LicensePlate: rec.LicensePlate,
                        CreatedAt: rec.CreatedAt,
                }
        }</span>
        <span class="cov0" title="0">return res</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package users

import (
        "context"
        "go-drop-logistik/business/users"

        "gorm.io/gorm"
)

type mysqlUsersRepository struct {
        Conn *gorm.DB
}

func NewMySQLUserRepository(conn *gorm.DB) users.Repository <span class="cov0" title="0">{
        return &amp;mysqlUsersRepository{
                Conn: conn,
        }
}</span>

func (repository *mysqlUsersRepository) GetByID(ctx context.Context, id int) (users.Domain, error) <span class="cov0" title="0">{
        usersById := Users{}
        result := repository.Conn.Where("users.id = ?", id).First(&amp;usersById)
        if result.Error != nil </span><span class="cov0" title="0">{
                return users.Domain{}, result.Error
        }</span>

        <span class="cov0" title="0">return *usersById.ToDomain(), nil</span>
}

func (repository *mysqlUsersRepository) GetByEmail(ctx context.Context, email string) (users.Domain, error) <span class="cov0" title="0">{
        rec := Users{}

        err := repository.Conn.Where("users.email = ?", email).First(&amp;rec).Error
        if err != nil </span><span class="cov0" title="0">{
                return users.Domain{}, err
        }</span>

        <span class="cov0" title="0">return *rec.ToDomain(), nil</span>
}

func (repository *mysqlUsersRepository) Register(ctx context.Context, userDomain *users.Domain) error <span class="cov0" title="0">{
        rec := fromDomain(*userDomain)

        result := repository.Conn.Create(rec)
        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package users

import (
        "go-drop-logistik/business/users"
        "time"
)

type Users struct {
        ID        int `gorm:"primary_key"`
        Name      string
        Password  string
        Email     string
        Roles     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (rec *Users) ToDomain() *users.Domain <span class="cov0" title="0">{
        return &amp;users.Domain{
                ID:        rec.ID,
                Name:      rec.Name,
                Password:  rec.Password,
                Email:     rec.Email,
                Roles:     rec.Roles,
                CreatedAt: rec.CreatedAt,
                UpdatedAt: rec.UpdatedAt,
        }
}</span>

func fromDomain(userDomain users.Domain) *Users <span class="cov0" title="0">{
        return &amp;Users{
                ID:        userDomain.ID,
                Name:      userDomain.Name,
                Password:  userDomain.Password,
                Email:     userDomain.Email,
                Roles:     userDomain.Roles,
                CreatedAt: userDomain.CreatedAt,
                UpdatedAt: userDomain.UpdatedAt,
        }
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package mysql_driver

import (
        "fmt"
        "go-drop-logistik/drivers/databases/admins"
        "go-drop-logistik/drivers/databases/agents"
        "go-drop-logistik/drivers/databases/drivers"
        "go-drop-logistik/drivers/databases/manifest"
        "go-drop-logistik/drivers/databases/manifestreceipt"
        "go-drop-logistik/drivers/databases/phoneagent"
        "go-drop-logistik/drivers/databases/phones"
        "go-drop-logistik/drivers/databases/receipts"
        "go-drop-logistik/drivers/databases/trackmanifest"
        "go-drop-logistik/drivers/databases/tracks"
        "go-drop-logistik/drivers/databases/trucks"
        "go-drop-logistik/drivers/databases/users"

        "log"

        "gorm.io/driver/mysql"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

type ConfigDB struct {
        DB_Username string
        DB_Password string
        DB_Host     string
        DB_Port     string
        DB_Database string
        Env         string
}

var (
        db  *gorm.DB
        err error
)

func (config *ConfigDB) InitialMysqlDB() *gorm.DB <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%v:%v@tcp(%v:%v)/%v?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                config.DB_Username,
                config.DB_Password,
                config.DB_Host,
                config.DB_Port,
                config.DB_Database)
                
        if config.Env != "PROD" </span><span class="cov0" title="0">{
                db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        }</span> else<span class="cov0" title="0"> {
                db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{
                        Logger: logger.Default.LogMode(logger.Silent),
                })
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">db.AutoMigrate(
                &amp;users.Users{},
                &amp;agents.Agents{},
                &amp;admins.Admins{},
                &amp;receipts.Receipts{},
                &amp;phones.Phones{},
                &amp;phoneagent.PhoneAgent{},
                &amp;manifest.Manifest{},
                &amp;manifestreceipt.ManifestReceipt{},
                &amp;tracks.Tracks{},
                &amp;trackmanifest.TrackManifest{},
                &amp;trucks.Trucks{},
                &amp;drivers.Drivers{},
        )

        return db</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package code

import (
        "strconv"
        "time"
)

func GenerateReceipt() string <span class="cov0" title="0">{
        timestamp := strconv.FormatInt(time.Now().Unix(), 10)
        receipt := "INV" + timestamp
        return receipt
}</span>

func GenerateManifest() string <span class="cov0" title="0">{
        timestamp := strconv.FormatInt(time.Now().Unix(), 10)
        receipt := "MNF" + timestamp
        return receipt
}</pre>
		
		<pre class="file" id="file73" style="display: none">package convertpointer

func ConvertPointerString(x *string) *string <span class="cov0" title="0">{
        if *x == "" </span><span class="cov0" title="0">{
                x = nil
        }</span>
        <span class="cov0" title="0">return x</span>
}

func ConvertNilPointerString(x *string) string <span class="cov0" title="0">{
        if x == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return *x</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package encrypt

import "golang.org/x/crypto/bcrypt"

func Hash(secret string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(secret), bcrypt.MinCost)
        return string(bytes), err
}</span>

func ValidateHash(secret, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(secret))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package guid

import (
        "github.com/google/uuid"
)

func GenerateUUID() string <span class="cov0" title="0">{
        return uuid.New().String()
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package logging

import (
        "flag"
        "os"
        "time"

        "github.com/labstack/echo/v4"
        log "github.com/sirupsen/logrus"
)

type Logger struct {
        Log *log.Logger
}

func NewLogger() Logger <span class="cov8" title="1">{
        logger := log.New()
        f, err := os.OpenFile("api.log", os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666)
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("cannot open 'testlogfile', (%s)", err.Error())
                flag.Usage()
                os.Exit(-1)
        }</span>
        <span class="cov8" title="1">logger.SetFormatter(&amp;log.JSONFormatter{})
        logger.SetOutput(f)
        return Logger{
                Log: logger,
        }</span>
}

func (l Logger) Logging(c echo.Context) *log.Entry <span class="cov0" title="0">{
        logs := l.Log

        if c == nil </span><span class="cov0" title="0">{
                return logs.WithFields(log.Fields{
                        "at": time.Now().Format("2006-01-02 15:04:05"),
                })
        }</span>

        <span class="cov0" title="0">return logs.WithFields(log.Fields{
                "at":     time.Now().Format("2006-01-02 15:04:05"),
                "method": c.Request().Method,
                "uri":    c.Request().URL.String(),
                "ip":     c.Request().RemoteAddr,
        })</span>
}

func (l Logger) LogEntry(request, response interface{}) *log.Entry <span class="cov0" title="0">{
        logs := l.Log

        return logs.WithFields(log.Fields{
                "at":       time.Now().Format("2006-01-02 15:04:05"),
                "request":  request,
                "response": response,
        })
}</span>

func (l Logger) LogServer(logServer string) *log.Entry <span class="cov0" title="0">{
        logs := log.New()

        logs.SetFormatter(&amp;log.JSONFormatter{})

        return logs.WithFields(log.Fields{
                "status": logServer,
        })
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package base_response

import (
        "net/http"

        echo "github.com/labstack/echo/v4"
)

type BaseResponse struct {
        Meta struct {
                Message string   `json:"message"`
                Errors  []string `json:"error,omitempty"`
        } `json:"meta"`
        Data interface{} `json:"data"`
}

func NewSuccessResponse(c echo.Context, param interface{}) error <span class="cov0" title="0">{
        response := BaseResponse{}
        response.Meta.Message = "Success"
        response.Data = param

        return c.JSON(http.StatusOK, response)
}</span>

func NewSuccessInsertResponse(c echo.Context, param interface{}) error <span class="cov0" title="0">{
        response := BaseResponse{}
        response.Meta.Message = "Success Insert"
        response.Data = param

        return c.JSON(http.StatusCreated, response)
}</span>

func NewErrorResponse(c echo.Context, status int, err error) error <span class="cov0" title="0">{
        response := BaseResponse{}
        response.Meta.Message = "Something wrong"
        response.Meta.Errors = []string{err.Error()}

        return c.JSON(status, response)
}</span>

func NewErrorValidateResponse(c echo.Context, status int, err error, param interface{}) error <span class="cov0" title="0">{
        response := BaseResponse{}
        response.Meta.Message = "Something wrong"
        response.Data = param

        return c.JSON(status, response)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package statuskey

import (
        "crypto/sha512"
        "errors"
        "fmt"
        "io"
)

func IsValid(orderID, StatusCode, Amount, SignKey, authKey string) error <span class="cov0" title="0">{
        key := fmt.Sprintf("%s%s%s%s", orderID, StatusCode, Amount, authKey)
        h512 := sha512.New()
        io.WriteString(h512, key)
        if fmt.Sprintf("%x", h512.Sum(nil)) != SignKey </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: Invalid sign key", errors.New("bad request"))
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package validation

import (
        ut "github.com/go-playground/universal-translator"
        "gopkg.in/go-playground/validator.v9"
)

var (
        vd    *validator.Validate
        trans ut.Translator
)

// Validate checking data
func Validate(data interface{}) (map[string]string, bool, error) <span class="cov0" title="0">{
        err := vd.Struct(data)
        if err != nil </span><span class="cov0" title="0">{
                errorMap := map[string]string{}
                errorType := ""
                for _, e := range err.(validator.ValidationErrors) </span><span class="cov0" title="0">{
                        if errorType == "" </span><span class="cov0" title="0">{
                                errorType = e.Tag()
                                errorMap[e.StructField()] = formatMessage(e, trans)
                        }</span> else<span class="cov0" title="0"> {
                                if e.Tag() == errorType </span><span class="cov0" title="0">{
                                        errorMap[e.StructField()] = formatMessage(e, trans)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return errorMap, true, nil</span>
        }
        <span class="cov0" title="0">return map[string]string{}, false, nil</span>
}

// Validation for initial function validation
func Init() <span class="cov0" title="0">{
        vd = validator.New()
}</span>

func formatMessage(err validator.FieldError, trans ut.Translator) string <span class="cov0" title="0">{
        message := ""

        switch err.Tag() </span>{
        case "phone_number":<span class="cov0" title="0">
                message = "nomor handphone tidak sesuai (081234567890)"</span>
        default:<span class="cov0" title="0">
                message = err.Translate(trans)</span>
        }
        <span class="cov0" title="0">return message</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
